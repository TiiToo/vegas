/*  Version: MPL 1.1/GPL 2.0/LGPL 2.1   The contents of this file are subject to the Mozilla Public License Version  1.1 (the "License"); you may not use this file except in compliance with  the License. You may obtain a copy of the License at  http://www.mozilla.org/MPL/    Software distributed under the License is distributed on an "AS IS" basis,  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License  for the specific language governing rights and limitations under the  License.    The Original Code is [maashaack framework].    The Initial Developers of the Original Code are  Zwetan Kjukov <zwetan@gmail.com> and Marc Alcaraz <ekameleon@gmail.com>.  Portions created by the Initial Developers are Copyright (C) 2006-2010  the Initial Developers. All Rights Reserved.    Contributor(s):    Alternatively, the contents of this file may be used under the terms of  either the GNU General Public License Version 2 or later (the "GPL"), or  the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),  in which case the provisions of the GPL or the LGPL are applicable instead  of those above. If you wish to allow use of your version of this file only  under the terms of either the GPL or the LGPL, and not to allow others to  use your version of this file under the terms of the MPL, indicate your  decision by deleting the provisions above and replace them with the notice  and other provisions required by the LGPL or the GPL. If you do not delete  the provisions above, a recipient may use your version of this file under  the terms of any one of the MPL, the GPL or the LGPL.*/package system.ioc {    import core.reflect.invoke;        import system.data.Identifiable;    import system.data.maps.HashMap;    import system.evaluators.Evaluable;
    import system.evaluators.MultiEvaluator;    import system.events.EventListener;    import system.ioc.builders.createObjectDefinition;    import system.ioc.strategies.ObjectFactoryMethod;    import system.ioc.strategies.ObjectStaticFactoryMethod;    import system.ioc.strategies.ObjectFactoryProperty;    import system.ioc.strategies.ObjectStaticFactoryProperty;    import system.ioc.strategies.ObjectFactoryReference;    import system.ioc.strategies.ObjectFactoryValue;
    import system.process.Lockable;    import system.signals.Receiver;    import system.signals.Signaler;        import flash.events.IEventDispatcher;        /**     * The basic Inversion of Control container/factory class.     * <p><b>Example :</b></p>     * <pre class="prettyprint">     * import flash.text.TextField ;     * import flash.text.TextFormat ;     *      * import system.ioc.ObjectFactory ;     *      * var factory:ObjectFactory = new ObjectFactory();     *      * var objects:Array =     * [     *     {     *         id         : "my_field" ,     *         type       : "flash.text.TextField" ,     *         properties :     *         [     *             { name:"defaultTextFormat" , value:new TextFormat("Verdana", 11) } ,     *             { name:"selectable"        , value:false                         } ,     *             { name:"text"              , value:"hello world"                 } ,     *             { name:"textColor"         , value:0xF7F744                      } ,     *             { name:"x"                 , value:100                           } ,     *             { name:"y"                 , value:100                           }     *         ]     *     }     * ];     *      * factory.create( objects );     *      * var field:TextField = factory.getObject("my_field") as TextField ;     *      * addChild(field) ;     * </pre>     */    public class ObjectFactory extends ObjectDefinitionContainer implements IObjectFactory    {        /**         * Creates a new ObjectFactory instance.         * @param config The optional configuration object of the factory.         * @param objects The optional Array contains generic objects to fill and initialize this factory.         */        public function ObjectFactory( config:ObjectConfig = null , objects:Array = null )        {            _singletons  = new HashMap() ;            this.config  = config || new ObjectConfig() ;            this.objects = objects ;        }                /**         * Determinates the configuration object of the object factory.         */        public function get config():ObjectConfig        {            return _config ;        }                /**         * @private         */        public function set config( o:ObjectConfig ):void        {            if ( _config )            {                _config.referenceEvaluator.factory = null ;            }            _config = o || new ObjectConfig() ;            _config.referenceEvaluator.factory = this ;        }                /**         * This array contains objects to fill this factory with the run or create method.         */        public var objects:Array ;                /**         * Returns the Map representation of all singletons register in this factory.         * @return the Map representation of all singletons register in this factory.         */        public function get singletons():HashMap        {            return _singletons ;        }                /**         * Returns <code class="prettyprint">true</code> if the referencial contains the specified object.         * @param id The 'id' of the object to search.         * @return <code class="prettyprint">true</code> if the referencial contains the specified object.         */        public function containsObject( name:String ):Boolean         {            return containsObjectDefinition(name);        }                /**         * Indicates if a singleton reference is register in the factory with the specified id.          * @param The 'id' of the singleton.         * @return <code class="prettyprint">true</code> if the singleton reference exist in the factory.         */        public function containsSingleton( id:String ):Boolean         {            return _singletons.containsKey(id) ;        }                /**         * Create the objects and fill the container.         * @param ...arguments An Array who contains all the "objects" settings.         */        public function create( ...arguments:Array ):void        {            run.apply( this, arguments ) ;        }                /**         * This method returns an object with the specified id in argument.         * @param id The 'id' of the object to return.         * @return the instance of the object with the id passed in argument.         */        public function getObject( id:String ):*        {            if ( id == null )            {               return null ;            }                        try            {                var definition:IObjectDefinition = getObjectDefinition( id ) ;                                if ( definition == null )                {                    throw new Error( this +  " get( " + id + " ) method failed, the object isn't register in the container.") ;                 }                                var isSingleton:Boolean = definition.isSingleton() ;                                var instance:* ;                                if ( isSingleton )                {                    instance = _singletons.get(id) || null ;                }                                if ( instance == null )                {                    ////////////// create the instance                                        try                    {                        var clazz:Class  = config.typeEvaluator.eval( definition.getType() ) as Class ;                        var strategy:IObjectFactoryStrategy = definition.getFactoryStrategy() ;                        if ( strategy )                        {                            instance = createObjectWithStrategy( strategy ) as clazz ;                        }                        else                        {                            instance = invoke( clazz , createArguments( definition.getConstructorArguments() ) ) as clazz ;                        }                    }                    catch( e:TypeError )                    {                        warn(this + " failed to create a new object, can't convert the instance with the specified type \"" + definition.getType() + "\" in the object definition \"" + definition.id + "\", this type don't exist in the application, or arguments limit exceeded, you can pass a maximum of 32 arguments.") ;                    }                                        ////////////// initialize the instance                                        if ( instance != null )                    {                        if ( isSingleton )                        {                            _singletons.put( id, instance ) ;                        }                                                dependsOn( definition ) ; // dependencies                                                populateIdentifiable ( instance , definition ) ; // identify                                                var flag:Boolean = isLockable( instance, definition ) ;                                                if ( flag )                        {                            (instance as Lockable).lock() ; // lock                        }                                                registerListeners( instance , definition.getBeforeListeners() ) ;                        registerReceivers( instance , definition.getBeforeReceivers() ) ;                                                populateProperties( instance , definition ) ; // init properties                                                registerListeners( instance , definition.getAfterListeners() ) ;                        registerReceivers( instance , definition.getAfterReceivers() ) ;                                                if ( flag )                        {                            (instance as Lockable).unlock() ; // unlock                        }                                                invokeInitMethod( instance , definition ) ; // init                                                generates( definition ) ; // generates                    }                }            }            catch( e:Error )            {                warn( this + " getObject failed with the id '" + id + "' : " + e.toString() ) ;            }                        return instance || null ;        }                /**         * Indicates if the factory is dirty, must flush this buffer of not lazy-init singleton object definitions.         * The user must execute the run or create methods to flush this buffer.         */        public function isDirty():Boolean        {            return bufferSingletons && bufferSingletons.length > 0 ;        }                /**         * This method indicates if the specified object definition is lazy init.         * @param id The 'id' of the object definition to check..         * @return <code class="prettyprint">true</code> if the specified object definition is lazy init.         */        public function isLazyInit( id:String ):Boolean         {            if ( containsObjectDefinition( id ) )            {                return getObjectDefinition(id).isLazyInit() ;            }            else            {                return false ;            }        }                /**         * This method defined if the scope of the specified object definition is "singleton".         * @param The 'id' of the object.         * @return <code class="prettyprint">true</code> if the object is a singleton.          */        public function isSingleton( id:String ):Boolean         {            if ( containsObjectDefinition( id ) )            {                return getObjectDefinition(id).isSingleton() ;            }            else            {                return false ;            }        }                /**         * Removes and destroy a singleton in the container.          * Invoke the <b>'destroy'</b> method of this object is it's define in the <code class="prettyprint">IObjectDefinition</code> of this singleton.         * @param id The id of the singleton to remove.          */        public function removeSingleton( id:String ):void        {            if ( isSingleton(id) && _singletons.containsKey(id) )            {                invokeDestroyMethod( _singletons.get(id), getObjectDefinition(id) ) ;                _singletons.remove( id ) ;            }        }                /**         * Run the initialization of the factory with new object definitions and create the not lazy-init singleton objects.         * <p><b>Example :</b></p>         * <pre class="prettyprint">         * import flash.text.TextField ;         * import flash.text.TextFormat ;         *          * import system.ioc.ObjectFactory ;         *          * var factory:ObjectFactory = new ObjectFactory();         *          * factory.objects =         * [         *     {         *         id         : "my_field" ,         *         type       : "flash.text.TextField" ,         *         properties :         *         [         *             { name:"defaultTextFormat" , value:new TextFormat("Verdana", 11) } ,         *             { name:"selectable"        , value:false                         } ,         *             { name:"text"              , value:"hello world"                 } ,         *             { name:"textColor"         , value:0xF7F744                      } ,         *             { name:"x"                 , value:100                           } ,         *             { name:"y"                 , value:100                           }         *         ]         *     }         * ];         *          * factory.run();         *          * var field:TextField = factory.getObject("my_field") as TextField ;         *          * addChild(field) ;         * </pre>         */        public override function run( ...arguments:Array ):void         {            if ( running )            {                return ;            }                        notifyStarted() ;                        if ( arguments[0] is Array )            {                objects = arguments[0] as Array ;            }                        if ( bufferSingletons == null )            {                bufferSingletons = [] ;            }                        if ( objects.length > 0)            {                var definition:ObjectDefinition ;                                var init:Object ;                                while ( objects.length > 0 )                {                    init = objects.shift() ;                                        if ( init != null )                    {                        definition = createObjectDefinition( init ) ;                                                addObjectDefinition( definition ) ;                                                if ( definition.isSingleton() && !definition.isLazyInit() )                        {                            if ( containsObject( definition.id ) )                            {                                bufferSingletons.push( String( definition.id ) ) ;                            }                        }                    }                    else                    {                        warn( this + " create new object definition failed with a 'null' or 'undefined' object." ) ;                    }                }            }                        // flush the buffer of singletons to initialize (no lazyInit)                        if ( bufferSingletons.length > 0 && !_config.lazyInit )            {                var size:int = bufferSingletons.length ;                for ( var i:int ; i < size ; i++ )                {                    getObject( bufferSingletons[i] as String ) ;                }                bufferSingletons = null ;            }                        notifyFinished() ;        }                /**         * The custom warn method of this factory to log a warning message in the application.         * You can overrides this method, the prototype object is dynamic.         */        public function warn( ...args:Array ):void        {            if ( config.useLogger )            {                logger.warn.apply( null , args ) ;            }            else            {                trace.apply(null, args) ;            }        }                /**         * The internal buffer of no lazyInit singletons (id) to create it in the run method if the config.lazyInit property is false.         */        protected var bufferSingletons:Array = [] ;                /**         * Creates the arguments Array representation of the specified definition.         * @return the arguments Array representation of the specified definition.         */        protected function createArguments( args:Array=null ):Array        {            if ( args == null )            {                return null ;            }            var len:int = args.length ;            if ( len > 0 )            {                var i:int ;                var stack:Array = [] ;                var item:ObjectArgument ;                var value:* ;                for ( ; i<len ; i++)                {                    item  = args[i] as ObjectArgument ;                    value = item.value ;                    try                    {                        if ( item.policy == ObjectAttribute.REFERENCE )                        {                            value = _config.referenceEvaluator.eval( value as String ) ;                        }                        else if ( item.policy == ObjectAttribute.CONFIG )                        {                            value = _config.configEvaluator.eval( value as String ) ;                        }                        else if ( item.policy == ObjectAttribute.LOCALE )                        {                            value = _config.localeEvaluator.eval( value as String ) ;                        }                        else                        {                            // do nothing                        }                        if ( item.evaluators != null && item.evaluators.length > 0 )                        {                            value = eval( value , item.evaluators  ) ;                        }                        stack.push( value ) ;                    }                    catch( e:Error )                    {                        warn( this + " createArguments failed : " + e.toString() ) ;                    }                }                return stack ;            }            else            {                return null ;            }        }                 /**         * Creates a new Object with a specified IObjectFactoryStrategy instance.         * @return A new Object with a specified IObjectFactoryStrategy instance.         */        protected function createObjectWithStrategy( strategy:IObjectFactoryStrategy ):*        {            if ( strategy == null )            {                return null ;            }            var args:Array ;            var instance:* = null ;            var clazz:Class ;            var factory:String ;            var ref:* ;            var name:String ;            var factoryMethod:ObjectMethod ;            if ( strategy is ObjectMethod )            {                factoryMethod = strategy as ObjectMethod ;                                name = factoryMethod.name ;                args = createArguments( factoryMethod.arguments ) ;                                if ( factoryMethod is ObjectStaticFactoryMethod )                {                    clazz  = config.typeEvaluator.eval( (factoryMethod as ObjectStaticFactoryMethod).type as String ) as Class ;                    if ( clazz != null && name in clazz )                     {                        instance = clazz[name].apply( null, args ) ;                    }                }                else if ( factoryMethod is ObjectFactoryMethod )                {                    factory  = (factoryMethod as ObjectFactoryMethod).factory ;                    ref      = getObject( factory ) ;                    if ( ( ref != null ) && ( name != null ) && ( name in ref ) )                     {                        instance = ref[name].apply( null, args ) ;                    }                }            }            else if ( strategy is ObjectProperty )            {                var factoryProperty:ObjectProperty = strategy as ObjectProperty ;                                name = factoryProperty.name ;                                if ( factoryProperty is ObjectStaticFactoryProperty )                {                    clazz = config.typeEvaluator.eval( (factoryProperty as ObjectStaticFactoryProperty).type as String ) as Class ;                    if ( clazz != null && name in clazz )                     {                        instance = clazz[name] ;                    }                }                else if ( factoryProperty is ObjectFactoryProperty )                {                    factory = (factoryProperty as ObjectFactoryProperty).factory ;                    if ( factory != null && containsObjectDefinition(factory) )                    {                        ref = getObject(factory) ;                        if ( ( ref != null ) && ( name != null ) && ( name in ref ) )                         {                            instance = ref[name] ;                        }                    }                }            }            else if ( strategy is ObjectFactoryValue )            {                instance = (strategy as ObjectFactoryValue).value ;            }            else if ( strategy is ObjectFactoryReference )            {                instance = _config.referenceEvaluator.eval((strategy as ObjectFactoryReference).ref ) ;            }            return instance ;        }                /**         * Invoked to creates all object in the factory register in the dependsOn collection.         * <p>All objects in the dependsOn collection are initialized before the initialization of the current object build in the factory.</p>         */        protected function dependsOn( definition:IObjectDefinition ):void        {            if ( definition.getDependsOn() != null )             {                var id:String ;                var ar:Array = definition.getDependsOn() ;                var size:int = ar.length ;                if ( size > 0 )                {                    for ( var i:int ; i<size ; i++ )                    {                        id = ar[i] as String ;                        if ( containsObjectDefinition(id))                        {                            getObject(id) ; // not keep in memory                        }                    }                }            }        }                /**         * Evaluates a value with an Array of evaluators or Evaluable references in the factory.         * @param value The value to evaluate.         * @param evaluators The Array who contains IEvaluator objects or String ids who representing a IEvaluator in the factory.         * @return The new value after evaluation.         */        protected function eval( value:* , evaluators:Array ):*        {            if ( evaluators == null || evaluators.length == 0 )            {                return value ;            }            _e.clear() ;            var o:* ;            var s:int   = evaluators.length ;            var a:Array = [] ;            for ( var i:int = 0 ; i < s ; i++ )            {                o = evaluators[i] ;                if ( o == null )                {                    continue ;                }                                if ( o is String )                {                    o = getObject( o as String ) ;                }                                if ( o is Evaluable )                {                    a.push( o ) ;                }            }            if ( a.length > 0 )            {                _e.add( a ) ;                value = _e.eval( value ) ;                _e.clear() ;            }            return value ;        }                   /**         * Invoked to creates all object in the factory register in the generates collection.         * <p>All objects in the generates collection are initialized after the initialization of the current object build in the factory.</p>         */        protected function generates( definition:IObjectDefinition ):void        {            if ( definition.getGenerates() != null )             {                var id:String ;                var ar:Array = definition.getGenerates() ;                var size:int = ar.length ;                if ( size > 0 )                {                    for ( var i:int ; i<size ; i++ )                    {                       id = ar[i] as String ;                       if ( containsObjectDefinition(id))                       {                           getObject(id) ; // not keep in memory                       }                    }                }            }        }                /**         * Invokes the destroy method of the specified object, if the init method is define in the IDefinition object.         */        protected function invokeDestroyMethod( o:* , definition:IObjectDefinition ):void        {            var name:String = definition.getDestroyMethodName();            if ( name == null && config != null )            {                name = config.defaultDestroyMethod ;            }            if( (name != null) && (name in o) && (o[name] is Function) )             {                (o[name] as Function).call(o) ;            }        }                 /**         * Invokes the init method of the specified object, if the init method is define in the IDefinition object.         */        protected function invokeInitMethod( o:* , definition:IObjectDefinition=null ):void        {            var name:String = definition.getInitMethodName();            if ( name == null && config != null )            {                name = config.defaultInitMethod ;            }            if( (name != null) && (name in o) && (o[name] is Function) )             {                (o[name] as Function).call(o) ;            }        }                /**         * Indicates if the specified object is Lockable and must be locked during the initialization of the properties and methods when is created.         */        protected function isLockable( o:* , definition:IObjectDefinition ):Boolean        {            return ( o is Lockable ) && ( ( definition.lock == true ) || ( config.lock === true && definition.lock != false ) ) ;        }                /**         * Populates the <code class="prettyprint">Identifiable</code> singleton object, if the 'identify' flag is true the config of this factory and if specified the <code class="prettyprint">IObjectDefinition</code> object scope is singleton.         */        protected function populateIdentifiable( o:* , definition:IObjectDefinition ):void        {            if ( definition.isSingleton() && o is Identifiable )            {                if ( ( definition.identify == true ) || ( config.identify === true && definition.identify != false ) )                {                    ( o as Identifiable ).id = definition.id ;                }            }        }                /**         * Populates all properties in the Map passed in argument.         */        protected function populateProperties( o:* , definition:IObjectDefinition ):void         {            var properties:Array = definition.getProperties() ;            if ( properties && properties.length > 0 )            {                var id:* = definition.id ;                var size:int = properties.length ;                for( var i:int ; i < size ; i++ )                {                    populateProperty( o , properties[i] as ObjectProperty , id ) ;                }            }         }                /**         * Populates a property in the specified object with the passed-in ObjectProperty object.         * @param o The object to populate.         * @param prop The ObjectProperty used to populate the object.         * @param id The id of the current IObjectDefinition.         */        protected function populateProperty( o:* , prop:ObjectProperty , id:* ):void         {            if ( o == null )            {                warn( this + " populate a new property failed, the object not must be 'null' or 'undefined', see the factory with the object definition '" + id + "'." ) ;                return ;            }                        var name:String = prop.name ;            var value:*     = prop.value ;                        //////////// #init magic strategy to populate the property                        if( name == MagicReference.INIT )            {                if ( prop.policy == ObjectAttribute.REFERENCE && value is String )                {                    value = _config.referenceEvaluator.eval( value as String ) ;                }                else if ( prop.policy == ObjectAttribute.CONFIG )                {                    value = config.configEvaluator.eval( value as String ) ;                }                else if ( prop.policy == ObjectAttribute.LOCALE )                {                    value = config.localeEvaluator.eval( value as String ) ;                }                if ( prop.evaluators && prop.evaluators.length > 0 )                {                    value = eval( value , prop.evaluators ) ;                }                if ( value )                {                    for( var member:String in value )                    {                        o[member] = value[member] ;                    }                }                else                {                    warn( this + " populate a new property failed with the magic name #init, the object to enumerate not must be null, see the factory with the object definition '" + id + "'." ) ;                }                return ;            }                        //////////// default strategy to populate the property                        if ( !( name in o ) )            {                warn( this + " populate a new property failed with the name:" + name + ", this property don't exist in the object:" + o + ", see the factory with the object definition '" + id + "'." ) ;                return ;            }            if ( o[name] is Function )            {                if( prop.policy == ObjectAttribute.ARGUMENTS )                {                    o[ name ].apply( o , createArguments( value as Array ) ) ;                    return ;                }                else if ( prop.policy == ObjectAttribute.VALUE && prop.value === undefined )                {                    o[ name ]() ;                    return ;                }            }            try            {                if ( prop.policy == ObjectAttribute.REFERENCE && value is String )                {                    value = _config.referenceEvaluator.eval( value as String ) ;                }                else if ( prop.policy == ObjectAttribute.CONFIG )                {                    value = config.configEvaluator.eval( value as String ) ;                }                else if ( prop.policy == ObjectAttribute.LOCALE )                {                    value = config.localeEvaluator.eval( value as String ) ;                }                if ( prop.evaluators && prop.evaluators.length > 0 )                {                    value = eval( value , prop.evaluators ) ;                }                o[ name ] = value ;            }            catch( e:Error )            {                warn( this + " populateProperty failed with the name '" + name + "' in the object '" + o + ", see the factory with the object definition '" + id + "' error: " + e.toString() ) ;            }        }                /**         * Initialize the listener callback of the specified object.         */        protected function registerListeners( o:* , listeners:Array ):void        {            if ( o == null || listeners == null )            {                return ;            }            var size:int = listeners.length ;            if ( size > 0 )            {                var dispatcher:IEventDispatcher ;                var method:Function ;                var listener:ObjectListener ;                for (var i:int ; i<size ; i++ )                 {                    try                    {                        method     = null ;                        listener   = listeners[i] as ObjectListener ;                        dispatcher = _config.referenceEvaluator.eval( listener.dispatcher ) as IEventDispatcher ;                        if ( dispatcher != null && listener.type != null )                        {                            if ( listener.method != null && listener.method in o )                             {                                method =  o[listener.method] as Function  ;                            }                            else if ( o is EventListener  )                            {                                method = ( o as EventListener).handleEvent ;                             }                            if ( method != null )                            {                                dispatcher.addEventListener( listener.type , method , listener.useCapture, listener.priority, listener.useWeakReference ) ;                              }                        }                    }                    catch( e:Error )                     {                        // do nothing                        warn( this + " registerListeners failed with the target '" + o + "' , in the collection of this listeners at {" + i + "} : " + e.toString() ) ;                        //                    }                }            }        }                /**         * Initialize the receiver callback of the specified object.         */        protected function registerReceivers( o:* , receivers:Array ):void        {            if ( o == null || receivers == null )            {                return ;            }            var size:int = receivers.length ;            if ( size > 0 )            {                var signaler:Signaler ;                var receiver:ObjectReceiver ;                var slot:Function ;                for (var i:int ; i<size ; i++ )                 {                    try                    {                        receiver = receivers[i] as ObjectReceiver ;                        signaler = _config.referenceEvaluator.eval( receiver.signal ) as Signaler ;                        slot     = null ;                        if ( signaler )                        {                            if ( ( receiver.slot != null ) && ( receiver.slot in o ) && ( o[receiver.slot] is Function ) )                            {                                slot = o[receiver.slot] as Function  ;                            }                            else if ( o is Receiver )                            {                                slot = ( o as Receiver).receive ;                             }                            if ( slot != null )                            {                                signaler.connect( slot , receiver.priority, receiver.autoDisconnect ) ;                            }                        }                    }                    catch( e:Error )                     {                        // do nothing                        warn( this + " registerReceivers failed with the target '" + o + "' , in the collection of this receivers at {" + i + "} : " + e.toString() ) ;                        //                    }                }            }        }                /**         * @private         */        private var _config:ObjectConfig ;                /**         * @private         */        private var _e:MultiEvaluator = new MultiEvaluator() ;                /**         * The maps of all objects in the container.         * @private         */        protected var _singletons:HashMap ;    }}