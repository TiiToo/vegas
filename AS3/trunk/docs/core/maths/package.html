<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><!-- saved from url=(0014)about:internet --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../prettify.css" type="text/css"><link rel="stylesheet" href="../../override.css" type="text/css"><title>core.maths Details</title></head><body><script language="javascript" type="text/javascript" src="../../prettify.js"></script><script language="javascript" type="text/javascript" src="../../asdoc.js"></script><script language="javascript" type="text/javascript" src="../../help.js"></script><script language="javascript" type="text/javascript" src="../../cookies.js"></script><script language="javascript" type="text/javascript"><!--
                asdocTitle = 'core.maths package - VEGAS AS3 Reference';
                var baseRef = '../../';
                window.onload = configPage;
            --></script>
<script type="text/javascript">
            scrollToNameAnchor();
        </script><table class="titleTable" cellpadding="0" cellspacing="0" id="titleTable" style="display:none"><tr><td class="titleTableTitle" align="left">VEGAS AS3 Reference</td><td class="titleTableTopNav" align="right"><a href="../../package-summary.html" onclick="loadClassListFrame('../../all-classes.html')">All Packages</a>&nbsp;|&nbsp;<a href="../../class-summary.html" onclick="loadClassListFrame('../../all-classes.html')">All Classes</a>&nbsp;|&nbsp;<a href="../../all-index-A.html" onclick="loadClassListFrame('../../index-list.html')">Index</a>&nbsp;|&nbsp;<a id="framesLink1" href="../../index.html?core/maths/package.html&amp;core/maths/class-list.html">Frames</a><a id="noFramesLink1" style="display:none" href="" onclick="parent.location=document.location"> No Frames </a></td><td class="titleTableLogo" align="right" rowspan="3"><img src="../../images/logo.jpg" class="logoImage" alt=" Adobe Logo " title=" Adobe Logo "></td></tr><tr class="titleTableRow2"><td class="titleTableSubTitle" id="subTitle" align="left">Package</td><td class="titleTableSubNav" id="subNav" align="right"><a href="package.html#constantSummary">Constants</a></td></tr><tr class="titleTableRow3"><td colspan="3">&nbsp;</td></tr></table><script language="javascript" type="text/javascript" xml:space="preserve">
                <!--
                
                    if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle("Package"); titleBar_setSubNav(false,false,false,false,false,false,false,false,false,false,true    ,false,false,false,false,false);}    
                -->
            </script><div class="MainContent"><br><a name="constantSummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Constants</div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableConstant"><tr><th>&nbsp;</th><th colspan="2">Constant</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#acosD" class="signatureLink">acosD</a> : Function<div class="summaryTableDescription">
     Returns the inverse cosine of a slope ratio and returns its angle in degrees.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#acosHm" class="signatureLink">acosHm</a> : Function<div class="summaryTableDescription">
     Anti-hyperbolic cosine.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#acosHp" class="signatureLink">acosHp</a> : Function<div class="summaryTableDescription">
     Anti-hyperbolic cosine.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#angleOfLine" class="signatureLink">angleOfLine</a> : Function<div class="summaryTableDescription">
     Returns the angle in degrees between 2 points with this coordinates passed in argument.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#asinD" class="signatureLink">asinD</a> : Function<div class="summaryTableDescription">
     Calculates the arcsine of the passed angle.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#asinH" class="signatureLink">asinH</a> : Function<div class="summaryTableDescription">
     Anti-hyperbolic sine.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#atan2D" class="signatureLink">atan2D</a> : Function<div class="summaryTableDescription">
     Calculates the arctangent2 of the passed angle.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#atanD" class="signatureLink">atanD</a> : Function<div class="summaryTableDescription">
     Calculates the arctangent of the passed angle.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#atanH" class="signatureLink">atanH</a> : Function<div class="summaryTableDescription">
     Anti-hyperbolic tangent.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#berp" class="signatureLink">berp</a> : Function<div class="summaryTableDescription">
     Short for 'boing-like interpolation', this method will first overshoot, then waver back and forth around the end value before coming to a rest.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#bounce" class="signatureLink">bounce</a> : Function<div class="summaryTableDescription">
     Returns a value between 0 and 1 that can be used to easily make bouncing GUI items (a la OS X's Dock)
     Example :
     
     import core.maths.bounce ;
     trace( bounce( 0.5 ) ) ; 
     
     </div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#cartesianToPolar" class="signatureLink">cartesianToPolar</a> : Function<div class="summaryTableDescription">
     Converts a vector in cartesian in a polar vector.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#ceil" class="signatureLink">ceil</a> : Function<div class="summaryTableDescription">
     Rounds and returns the ceiling of the specified number or expression.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#clamp" class="signatureLink">clamp</a> : Function<div class="summaryTableDescription">
     Bounds a numeric value between 2 numbers.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#clerp" class="signatureLink">clerp</a> : Function<div class="summaryTableDescription">
     Circular Lerp is like lerp but handles the wraparound from 0 to 360.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#cosD" class="signatureLink">cosD</a> : Function<div class="summaryTableDescription">
     Calculates the cosine of the passed angle.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#coserp" class="signatureLink">coserp</a> : Function<div class="summaryTableDescription">
     Short for 'cosinusoidal interpolation', this method will interpolate while easing around the end, when value is near one.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#cosH" class="signatureLink">cosH</a> : Function<div class="summaryTableDescription">
     Hyperbolic cosine.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#DEG2RAD" class="signatureLink">DEG2RAD</a> : Number = 0.017453292519943295<div class="summaryTableDescription">
    This constant change degrees to radians : Math.PI/180.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#degreesToRadians" class="signatureLink">degreesToRadians</a> : Function<div class="summaryTableDescription">
     Converts an angle in degrees in radians
     </div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#distance" class="signatureLink">distance</a> : Function<div class="summaryTableDescription">
     Returns the distance between 2 points with the coordinates of the 2 points.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#distanceByObject" class="signatureLink">distanceByObject</a> : Function<div class="summaryTableDescription">
     Returns the distance between 2 points with the coordinates of the 2 points.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#EPSILON" class="signatureLink">EPSILON</a> : Number = 0.000000001<div class="summaryTableDescription">
    Represents the smallest positive Single value greater than zero.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#fixAngle" class="signatureLink">fixAngle</a> : Function<div class="summaryTableDescription">
     Fixs an angle in degrees between 0 and 360 degrees.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#floor" class="signatureLink">floor</a> : Function<div class="summaryTableDescription">
     Rounds and returns a number by a count of floating points.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#gcd" class="signatureLink">gcd</a> : Function<div class="summaryTableDescription">
     Returns the greatest common divisor with the Euclidean algorithm.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#hermite" class="signatureLink">hermite</a> : Function<div class="summaryTableDescription">
     This method will interpolate while easing in and out at the limits.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#hypothenuse" class="signatureLink">hypothenuse</a> : Function<div class="summaryTableDescription">
     Calculates the hypothenuse value of the two passed-in triangle sides value.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#interpolate" class="signatureLink">interpolate</a> : Function<div class="summaryTableDescription">
     With a number value and a range this method returns the actual value for the interpolated value in that range.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#isEven" class="signatureLink">isEven</a> : Function<div class="summaryTableDescription">
     Indicates if an integer that is "evenly divisible" by 2.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#isOdd" class="signatureLink">isOdd</a> : Function<div class="summaryTableDescription">
     Indicates if an integer that is not "evenly divisible" by 2.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#LAMBDA" class="signatureLink">LAMBDA</a> : Number = 0.57721566490143<div class="summaryTableDescription">
    This constant is the Euler-Mascheroni constant (lambda or C) :
    
    
    ( n )
    lim( sigma 1/k - ln(n) )
    n->oo ( k=1 )
    
    
    </div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#lerp" class="signatureLink">lerp</a> : Function<div class="summaryTableDescription">
     Calculates a number between two numbers at a specific increment.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#log10" class="signatureLink">log10</a> : Function<div class="summaryTableDescription">
     Calculates the log10 of the specified value.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#logN" class="signatureLink">logN</a> : Function<div class="summaryTableDescription">
     Calculates the logN of the specified value.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#map" class="signatureLink">map</a> : Function<div class="summaryTableDescription">
     Takes a value in a given range (minimum1, maximum1) and finds the corresponding value in the next range(minimum2, maximum2).</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#normalize" class="signatureLink">normalize</a> : Function<div class="summaryTableDescription">
     Takes a value within a given range and converts it to a number between 0 and 1.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#percentage" class="signatureLink">percentage</a> : Function<div class="summaryTableDescription">
     Returns a percentage or null.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#PHI" class="signatureLink">PHI</a> : Number = 1.61803398874989<div class="summaryTableDescription">
    This constant is the golden ratio (phi) : ( 1 + Math.sqrt(5) ) / 2.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#polarToCartesian" class="signatureLink">polarToCartesian</a> : Function<div class="summaryTableDescription">
     Converts a Polar object in a cartesian vector.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#RAD2DEG" class="signatureLink">RAD2DEG</a> : Number = 57.29577951308232<div class="summaryTableDescription">
    This constant change radians to degrees : 180/Math.PI.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#radiansToDegrees" class="signatureLink">radiansToDegrees</a> : Function<div class="summaryTableDescription">
     Converts an angle in radians in degrees
     </div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#replaceNaN" class="signatureLink">replaceNaN</a> : Function<div class="summaryTableDescription">
     Replace the passed-in Number value, if the value is NaN the return value is the default value in second argument.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#round" class="signatureLink">round</a> : Function<div class="summaryTableDescription">
     Rounds and returns a number by a count of floating points.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#sign" class="signatureLink">sign</a> : Function<div class="summaryTableDescription">
     Returns 1 if the value is positive or -1.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#sinD" class="signatureLink">sinD</a> : Function<div class="summaryTableDescription">
     Calculates the sine of the passed angle.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#sinerp" class="signatureLink">sinerp</a> : Function<div class="summaryTableDescription">
     Short for 'sinusoidal interpolation', this method will interpolate while easing around the end, when value is near one.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#sinH" class="signatureLink">sinH</a> : Function<div class="summaryTableDescription">
     Hyperbolic sine.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#tanD" class="signatureLink">tanD</a> : Function<div class="summaryTableDescription">
     Calculates the tangent of the passed angle.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#tanH" class="signatureLink">tanH</a> : Function<div class="summaryTableDescription">
     Hyperbolic tangent.</div></td><td class="summaryTableOwnerCol">core.maths</td></tr></table></div><div class="detailSectionHeader"> Constant Detail </div><a name="constantDetail"></a><a name="DEG2RAD"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">DEG2RAD</td><td class="detailHeaderType">Constant</td></tr></table><div class="detailBody"><code>public const DEG2RAD:Number = 0.017453292519943295</code><p></p><p></p><p>
    This constant change degrees to radians : <b>Math.PI/180</b>.
    </p></div><a name="constantDetail"></a><a name="EPSILON"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">EPSILON</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const EPSILON:Number = 0.000000001</code><p></p><p></p><p>
    Represents the smallest positive Single value greater than zero.
    </p></div><a name="constantDetail"></a><a name="LAMBDA"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">LAMBDA</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const LAMBDA:Number = 0.57721566490143</code><p></p><p></p><p>
    This constant is the Euler-Mascheroni constant (lambda or C) :
    <p>
    <pre>
    ( n )
    lim( sigma 1/k - ln(n) )
    n->oo ( k=1 )
    </pre>
    </p>
    </p></div><a name="constantDetail"></a><a name="PHI"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">PHI</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const PHI:Number = 1.61803398874989</code><p></p><p></p><p>
    This constant is the golden ratio (phi) : <b>( 1 + Math.sqrt(5) ) / 2</b>.
    </p></div><a name="constantDetail"></a><a name="RAD2DEG"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">RAD2DEG</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const RAD2DEG:Number = 57.29577951308232</code><p></p><p></p><p>
    This constant change radians to degrees : <b>180/Math.PI</b>.
    </p></div><a name="constantDetail"></a><a name="acosD"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">acosD</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const acosD:Function</code><p></p><p></p><p>
     Returns the inverse cosine of a slope ratio and returns its angle in degrees.
     </p></div><a name="constantDetail"></a><a name="acosHm"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">acosHm</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const acosHm:Function</code><p></p><p></p><p>
     Anti-hyperbolic cosine.
     <pre>
     acoshm = ln(x-√(x^2-1))
     </pre>
     </p></div><a name="constantDetail"></a><a name="acosHp"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">acosHp</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const acosHp:Function</code><p></p><p></p><p>
     Anti-hyperbolic cosine.
     <pre>
     acoshp = ln(x+√(x^2-1))
     </pre>
     </p></div><a name="constantDetail"></a><a name="angleOfLine"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">angleOfLine</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const angleOfLine:Function</code><p></p><p></p><p>
     Returns the angle in degrees between 2 points with this coordinates passed in argument.
     </p></div><a name="constantDetail"></a><a name="asinD"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">asinD</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const asinD:Function</code><p></p><p></p><p>
     Calculates the arcsine of the passed angle.
     </p></div><a name="constantDetail"></a><a name="asinH"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">asinH</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const asinH:Function</code><p></p><p></p><p>
     Anti-hyperbolic sine.
     </p></div><a name="constantDetail"></a><a name="atan2D"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">atan2D</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const atan2D:Function</code><p></p><p></p><p>
     Calculates the arctangent2 of the passed angle.
     </p></div><a name="constantDetail"></a><a name="atanD"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">atanD</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const atanD:Function</code><p></p><p></p><p>
     Calculates the arctangent of the passed angle.
     </p></div><a name="constantDetail"></a><a name="atanH"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">atanH</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const atanH:Function</code><p></p><p></p><p>
     Anti-hyperbolic tangent.
     </p></div><a name="constantDetail"></a><a name="berp"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">berp</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const berp:Function</code><p></p><p></p><p>
     Short for 'boing-like interpolation', this method will first overshoot, then waver back and forth around the end value before coming to a rest.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.berp ;
     trace( berp( 0 , 100 , 0.5 ) ; 
     </pre>
     </p></div><a name="constantDetail"></a><a name="bounce"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">bounce</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const bounce:Function</code><p></p><p></p><p>
     Returns a value between 0 and 1 that can be used to easily make bouncing GUI items (a la OS X's Dock)
     <p><b>Example :</b></p>
     <pre>
     import core.maths.bounce ;
     trace( bounce( 0.5 ) ) ; 
     </pre>
     </p></div><a name="constantDetail"></a><a name="cartesianToPolar"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">cartesianToPolar</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const cartesianToPolar:Function</code><p></p><p></p><p>
     Converts a vector in cartesian in a polar vector. Return a generic object with the properties angle and radius.
     </p></div><a name="constantDetail"></a><a name="ceil"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">ceil</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const ceil:Function</code><p></p><p></p><p>
     Rounds and returns the ceiling of the specified number or expression. 
     The ceiling of a number is the closest integer that is greater than or equal to the number.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.ceil ;
     
     var n:Number ;
     
     n = ceil(4.572525153, 2) ;
     trace ("n : " + n) ; // n : 4.58
     
     n = ceil(4.572525153, -1) ;
     trace ("n : " + n) ; // n : 5
     </pre>
     </p></div><a name="constantDetail"></a><a name="clamp"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">clamp</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const clamp:Function</code><p></p><p></p><p>
     Bounds a numeric value between 2 numbers.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.clamp ;
     
     var n:Number ;
     
     n = clamp(4, 5, 10) ;
     trace ("n : " + n) ; // 5
     
     n = clamp(12, 5, 10) ;
     trace ("n : " + n) ; // 10
     
     n = clamp(6, 5, 10) ;
     trace ("n : " + n) ; // 5
     
     var n = clamp(NaN, 5, 10) ;
     trace ("n : " + n) ; // NaN
     </pre>
     </p></div><a name="constantDetail"></a><a name="clerp"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">clerp</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const clerp:Function</code><p></p><p></p><p>
     Circular Lerp is like lerp but handles the wraparound from 0 to 360. 
     This is useful when interpolating eulerAngles and the object crosses the 0/360 boundary. 
     The standard Lerp function causes the object to rotate in the wrong direction and looks stupid, clerp() fixes that.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.clerp ;
     trace( clerp( 0 , 180 , 0.5 ) ; // 90
     </pre>
     </p></div><a name="constantDetail"></a><a name="cosD"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">cosD</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const cosD:Function</code><p></p><p></p><p>
     Calculates the cosine of the passed angle.
     </p></div><a name="constantDetail"></a><a name="cosH"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">cosH</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const cosH:Function</code><p></p><p></p><p>
     Hyperbolic cosine.
     </p></div><a name="constantDetail"></a><a name="coserp"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">coserp</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const coserp:Function</code><p></p><p></p><p>
     Short for 'cosinusoidal interpolation', this method will interpolate while easing around the end, when value is near one.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.coserp ;
     trace( coserp( 0 , 100 , 0.5 ) ;
     </pre>
     </p></div><a name="constantDetail"></a><a name="degreesToRadians"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">degreesToRadians</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const degreesToRadians:Function</code><p></p><p></p><p>
     Converts an angle in degrees in radians
     </p></div><a name="constantDetail"></a><a name="distanceByObject"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">distanceByObject</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const distanceByObject:Function</code><p></p><p></p><p>
     Returns the distance between 2 points with the coordinates of the 2 points.
     </p></div><a name="constantDetail"></a><a name="distance"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">distance</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const distance:Function</code><p></p><p></p><p>
     Returns the distance between 2 points with the coordinates of the 2 points.
     </p></div><a name="constantDetail"></a><a name="fixAngle"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">fixAngle</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const fixAngle:Function</code><p></p><p></p><p>
     Fixs an angle in degrees between 0 and 360 degrees.
     </p></div><a name="constantDetail"></a><a name="floor"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">floor</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const floor:Function</code><p></p><p></p><p>
     Rounds and returns a number by a count of floating points.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.floor ;
     
     var n:Number ;
     
     n = floor(4.572525153, 2) ;
     trace ("n : " + n) ; // n : 4.57
     
     n = floor(4.572525153, -1) ;
     trace ("n : " + n) ; // n : 4
     </pre>
     </p></div><a name="constantDetail"></a><a name="gcd"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">gcd</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const gcd:Function</code><p></p><p></p><p>
     Returns the greatest common divisor with the Euclidean algorithm.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.gcd ;
     
     trace("gcd(320,240) : " + gcd(320,240) ) ; // gcd(320,240) : 80
     </pre>
     </p></div><a name="constantDetail"></a><a name="hermite"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">hermite</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const hermite:Function</code><p></p><p></p><p>
     This method will interpolate while easing in and out at the limits.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.hermite ;
     trace( hermite( 0 , 100 , 0.5 ) ; // 50
     </pre>
     </p></div><a name="constantDetail"></a><a name="hypothenuse"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">hypothenuse</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const hypothenuse:Function</code><p></p><p></p><p>
     Calculates the hypothenuse value of the two passed-in triangle sides value.
     <p>A hypotenuse is the longest side of a right triangle (Right-angled triangle in British English), the side opposite the right angle. The length of the hypotenuse of a right triangle can be found using the Pythagorean theorem, which states that the square of the length of the hypotenuse equals the sum of the squares of the lengths of the other two sides.</p>
     </p></div><a name="constantDetail"></a><a name="interpolate"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">interpolate</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const interpolate:Function</code><p></p><p></p><p>
     With a number value and a range this method returns the actual value for the interpolated value in that range.
     <pre>
     import core.maths.interpolate ;
     
     trace( interpolate( 0.5, 0 , 100 ) ) ; // 50
     </pre>
     </p></div><a name="constantDetail"></a><a name="isEven"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">isEven</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const isEven:Function</code><p></p><p></p><p>
     Indicates if an integer that is "evenly divisible" by 2.
     </p></div><a name="constantDetail"></a><a name="isOdd"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">isOdd</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const isOdd:Function</code><p></p><p></p><p>
     Indicates if an integer that is not "evenly divisible" by 2.
     </p></div><a name="constantDetail"></a><a name="lerp"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">lerp</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const lerp:Function</code><p></p><p></p><p>
     Calculates a number between two numbers at a specific increment. 
     The lerp function is convenient for creating motion along a straight path and for drawing dotted lines.
     <p>Lerp is an abbreviation for linear interpolation, which can also be used as a verb (Raymond 2003).</p> 
     <p>Linear interpolation is a method of curve fitting using linear polynomials. 
     It is heavily employed in mathematics (particularly numerical analysis), and numerous applications including computer graphics. It is a simple form of interpolation.</p>
     <p><b>Example :</b></p>
     <pre>
     import core.maths.lerp ;
     trace( lerp( 0 , 100 , 0.5 ) ; // 50
     </pre>
     </p></div><a name="constantDetail"></a><a name="log10"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">log10</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const log10:Function</code><p></p><p></p><p>
     Calculates the log10 of the specified value.
     </p></div><a name="constantDetail"></a><a name="logN"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">logN</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const logN:Function</code><p></p><p></p><p>
     Calculates the logN of the specified value.
     </p></div><a name="constantDetail"></a><a name="map"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">map</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const map:Function</code><p></p><p></p><p>
     Takes a value in a given range (minimum1, maximum1) and finds the corresponding value in the next range(minimum2, maximum2).
     <pre>
     import core.maths.map ;
     
     trace( map( 10,  0, 100, 20, 80  ) ) ; // 26
     trace( map( 26, 20,  80,  0, 100 ) ) ; // 10
     </pre>
     </p></div><a name="constantDetail"></a><a name="normalize"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">normalize</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const normalize:Function</code><p></p><p></p><p>
     Takes a value within a given range and converts it to a number between 0 and 1.
     Actually it can be outside that range if the original value is outside its range.
     <pre>
     import core.maths.normalize ;
     
     trace( normalize( 10, 0 , 100 ) ) ; // 0.1
     </pre>
     </p></div><a name="constantDetail"></a><a name="percentage"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">percentage</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const percentage:Function</code><p></p><p></p><p>
     Returns a percentage or null.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.percentage ;
     
     trace( percentage( 50 , 100 ) + "%" ) ; // 50%
     trace( percentage( 68 , 425 ) + "%" ) ; // 16% 
     </pre>
     </p></div><a name="constantDetail"></a><a name="polarToCartesian"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">polarToCartesian</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const polarToCartesian:Function</code><p></p><p></p><p>
     Converts a Polar object in a cartesian vector.
     </p></div><a name="constantDetail"></a><a name="radiansToDegrees"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">radiansToDegrees</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const radiansToDegrees:Function</code><p></p><p></p><p>
     Converts an angle in radians in degrees
     </p></div><a name="constantDetail"></a><a name="replaceNaN"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">replaceNaN</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const replaceNaN:Function</code><p></p><p></p><p>
     Replace the passed-in Number value, if the value is NaN the return value is the default value in second argument.
     </p></div><a name="constantDetail"></a><a name="round"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">round</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const round:Function</code><p></p><p></p><p>
     Rounds and returns a number by a count of floating points.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.round ;
     
     var n:Number ;
     
     n = round(4.572525153, 2) ;
     trace ("n : " + n) ; // 4.57
     
     var n = round(4.572525153, -1) ;
     trace ("n : " + n) ; // 5
     </pre>
     </p></div><a name="constantDetail"></a><a name="sign"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">sign</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const sign:Function</code><p></p><p></p><p>
     Returns 1 if the value is positive or -1.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.sign ;
     
     var n:int ;
     
     n = sign(-150) ;
     trace ("n : " + n) ; // -1
     
     n = sign(200) ;
     trace ("n : " + n) ; // 1
     
     n = sign(0) ;
     trace ("n : " + n) ; // 1
     </pre>
     </p><br/><span class="label"> Throws </span><br/><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>IllegalOperationError </code> &mdash; if the passed-in value is NaN.
     </td></tr></table></div><a name="constantDetail"></a><a name="sinD"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">sinD</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const sinD:Function</code><p></p><p></p><p>
     Calculates the sine of the passed angle.
     </p></div><a name="constantDetail"></a><a name="sinH"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">sinH</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const sinH:Function</code><p></p><p></p><p>
     Hyperbolic sine.
     </p></div><a name="constantDetail"></a><a name="sinerp"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">sinerp</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const sinerp:Function</code><p></p><p></p><p>
     Short for 'sinusoidal interpolation', this method will interpolate while easing around the end, when value is near one.
     <p><b>Example :</b></p>
     <pre>
     import core.maths.sinerp ;
     trace( sinerp( 0 , 100 , 0.5 ) ;
     </pre>
     </p></div><a name="constantDetail"></a><a name="tanD"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">tanD</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const tanD:Function</code><p></p><p></p><p>
     Calculates the tangent of the passed angle.
     </p></div><a name="constantDetail"></a><a name="tanH"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">tanH</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public const tanH:Function</code><p></p><p></p><p>
     Hyperbolic tangent.
     </p></div><p></p><center class="copyright"><footer></footer><br/>Vendredi Mai 13 2011, 11:31 AM +02:00  </center></div></body></html>