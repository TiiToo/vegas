/*

  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at 
  
           http://www.mozilla.org/MPL/ 
  
  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the License. 
  
  The Original Code is Vegas Framework.
  
  The Initial Developer of the Original Code is
  ALCARAZ Marc (aka eKameleon)  <vegas@ekameleon.net>.
  Portions created by the Initial Developer are Copyright (C) 2004-2007
  the Initial Developer. All Rights Reserved.
  
  Contributor(s) :
  
*/

/**
 * @author eKameleon
 */
if (asgard.net.remoting.RemotingService == undefined) 
{
	
	/**
	 * @requires asgard.events.RemotingEvent
	 */
	require("asgard.events.RemotingEvent") ;

	/**
	 * @requires asgard.net.remoting.RemotingAuthentification
	 */
	require("asgard.net.remoting.RemotingAuthentification") ;

	/**
	 * @requires asgard.net.remoting.RemotingConnection
	 */
	require("asgard.net.remoting.RemotingConnection") ;

	/**
	 * @requires asgard.net.remoting.RemotingConnectionCollecto
	 */
	require("asgard.net.remoting.RemotingConnectionCollector") ;

	/**
	 * @requires asgard.net.remoting.RemotingFormat
	 */
	require("asgard.net.remoting.RemotingFormat") ;

	/**
	 * @requires asgard.net.remoting.RemotingServiceResponder
	 */
	require("asgard.net.remoting.RemotingServiceResponder") ;

	/**
	 * @requires pegas.process.AbstractAction
	 */
	require("pegas.process.AbstractAction") ;
	
	/**
	 * Creates a new RemotingService instance.
	 */
	asgard.net.remoting.RemotingService = function( gatewayUrl /*String*/ , serviceName /*String*/ , responder /*RemotingServiceResponder*/ )
	{
		
		var RemotingEvent = asgard.events.RemotingEvent ;
		
		pegas.process.AbstractAction.call(this) ;
		
		this.setGatewayUrl( gatewayUrl );
		this.setServiceName( serviceName ) ;
		this.setResponder( responder ) ;
		
		this._eFinish = new RemotingEvent(RemotingEvent.FINISH, this) ;
		this._eProgress = new RemotingEvent(RemotingEvent.PROGRESS, this) ;
		this._eStart = new RemotingEvent(RemotingEvent.START, this) ;
		
		this._eError = new RemotingEvent(RemotingEvent.ERROR, this)  ;
		
		// _global.System.onStatus = Delegate.create (this, _onStatus) ;
		
	}
	
	/**
	 * const the level error string representation.
	 */
	asgard.net.remoting.RemotingService.LEVEL_ERROR /*String*/ = "error" ;
	
	/**
	 * Inherit asgard.process.AbstractAction.
	 */
	asgard.net.remoting.RemotingService.extend( pegas.process.AbstractAction ) ;
 
 	p = asgard.net.remoting.RemotingService.prototype ;

	/**
	 * If this value is 'true' the service can launch multiple method in the same time.
	 */
	p.multipleSimultaneousAllowed /*Boolean*/ = null ;
 
	/**
	 * Returns a shallow copy of the object.
	 */
	p.clone = function () 
	{
		return new asgard.net.remoting.RemotingService( this.gatewayUrl() , this.getServiceName() ) ;
	}

	/**
	 * Returns the internal RemotingConnection reference.
	 */
	p.getConnection = function () 
	{
		return this._rc ;	
	}

	/**
	 * Returns 'true' if the service is in proxy mode.
	 */
	p.getIsProxy = function () /*Boolean*/ 
	{
		return this._isProxy ;	
	}
	
	/**
	 * Returns the url of the gateway.
	 */
	p.getGatewayUrl = function () /*String*/ 
	{
		return this._gatewayUrl ;	
	}

	/**
	 * Returns the name of the method.
	 */
	p.getMethodName = function () /*String*/ 
	{
		return this._methodName ;
	}

	/**
	 * Returns an array of all the arguments passed in the method.
	 */
	p.getParams = function () /*Array*/ 
	{
		return this._args  ;	
	}

	/**
	 * Returns the internal RemotingServiceResponder reference.
	 */
	p.getResponder = function () /*RemotingServiceResponder*/ 
	{
		return this._responder ;
	}

	/**
	 * Returns the result of the method.
	 */
	p.getResult = function () 
	{
		return this._result ;	
	}

	/**
	 * Returns the name of the service.
	 */
	p.getServiceName = function () /*String*/ 
	{
		return this._serviceName ;
	}

	/**
	 * Notify an error.
	 */
	p.notifyError = function ( code /*String*/ ) /*Void*/ 
	{
		this._setRunning(false) ;
		this._eError.code = code || asgard.events.RemotingEvent.ERROR ;
		this.dispatchEvent( _eError ) ;
		this.notifyFinished() ;
	}	

	/**
	 * Invoqued if the service is failed.
	 */
	p.onFault = function ( e /*RemotingEvent*/ ) /*void*/ 
	{
		this.setRunning(false) ;
		e.setTarget(this) ;
		this.dispatchEvent( e ) ;
		this.notifyFinished() ;
	}

	/**
	 * Invoqued if the service is success.
	 */
	p.onResult = function ( e /*RemotingEvent*/ ) /*void*/ 
	{
		
		this.setRunning(false) ;
		e.setTarget(this) ;
		
		this._result = e.getResult() ;
		
		this.dispatchEvent( e ) ;
		
		this.notifyFinished() ;
	}

	/**
	 * Launch the service connection.
	 */
	p.run = function () /*void*/ 
	{
		
		if (this._rc == null ) 
		{
			// ici notifier qu'il est impossible de lancer la connection.	
		}
		
		if (this._authentification != null)
		{
			this._rc.setCredentials(this._authentification) ;
		}
		
		if ( this.getRunning() && this.multipleSimultaneousAllowed == false)  
		{
			this.notifyProgress() ;
		}
		else 
		{
			this.notifyStarted() ;
			this._result = null ;
			this.setRunning(true) ;
			var arg /*Array*/ = [this._serviceName + "." + this._methodName , this.getResponder()].concat(this._args) ;
			this._rc.call.apply( this._rc, arg );
		} 
	}
	
	/**
	 * Sets the credentials value of this service.
	 * @see RemotingAuthentification
	 */
	p.setCredentials = function ( authentification /*RemotingAuthentification*/ ) /*Void*/  
	{
		this._authentification = authentification ;
	}
	
	/**
	 * Sets the gateway url.
	 */
	p.setGatewayUrl = function ( url /*String*/ ) /*Void*/ 
	{
		if (this._gatewayUrl) 
		{
			asgard.net.remoting.RemotingConnectionCollector.remove(this._gatewayUrl) ;
		}
		if (url) 
		{
			this._gatewayUrl = url ;
			this._rc = asgard.net.remoting.RemotingConnection.getConnection( this._gatewayUrl ) ;
		}
		else 
		{
			this._rc = null ;	
		}
	}

	/**
	 * Sets the service is in proxy mode.
	 */
	p.setIsProxy = function (b /*Boolean*/) /*Void*/ 
	{
		this._isProxy = b ;
		this.__resolve = b ? this.__resolve__ : null ;	
	}
	
	/**
	 * Sets the name of the method.
	 */
	p.setMethodName = function ( sName /*String*/ ) /*void*/ 
	{
		this._methodName = sName ;	
	}

	/**
	 * Sets the arguments of the method.
	 */
	p.setParams = function ( args /*Array*/ ) /*void*/ 
	{
		this._args = args ;	
	}

	/**
	 * Sets an external RemotingServiceResponder reference.
	 */
	p.setResponder = function ( responder /*RemotingServiceResponder*/ ) /*Void*/ 
	{
		if (this._responder)
		{
			this._responder.setService(null) ;
		}
		this._responder = responder || new asgard.net.remoting.RemotingServiceResponder(this, this.onResult, this.onFault) ;
		this._responder.setService(this) ;
	}

	/**
	 * Sets the service name.
	 */
	p.setServiceName = function ( sName /*String*/ ) /*Void*/ 
	{
		this._serviceName = sName ;	
	}

	/**
	 * Trigger the service.
	 */
	p.trigger = function () /*void*/ 
	{
		this.run() ;	
	}

	/**
	 * Returns a string representation of the object.
	 */
	p.toString = function () /*String*/ 
	{
		var f = new asgard.net.remoting.RemotingFormat() ; 
		return f.formatToString(this) ;	
	}

	/**
	 * (read-write) The gateway url of the service.
	 */
	vegas.util.factory.PropertyFactory.create(p, "gatewayUrl") ;

	/**
	 * (read-write) Defined if the service is in proxy mode.
	 */
	vegas.util.factory.PropertyFactory.create(p, "isProxy") ;
	
	/**
	 * (read-write) Defined the arguments to send with the method.
	 */
	vegas.util.factory.PropertyFactory.create(p, "params") ;
	
	/**
	 * (read-write) The name of the method.
	 */
	vegas.util.factory.PropertyFactory.create(p, "methodName") ;

	/**
	 * (read-write) The name of the service.
	 */
	vegas.util.factory.PropertyFactory.create(p, "serviceName") ;

	/**
	 * @private
	 */
	p._args /*Array*/ = null ;

	/**
	 * @private
	 */
	p._authentification /*RemotingAuthentification*/ = null ;

	/**
	 * @private
	 */
	p._eError /*RemotingEvent*/ = null ;

	/**
	 * @private
	 */
	p._eFinish /*RemotingEvent*/ = null ;

	/**
	 * @private
	 */
	p._eProgress /*RemotingEvent*/ = null ;

	/**
	 * @private
	 */
	p._eStart /*RemotingEvent*/ = null ;

	/**
	 * Internal gateway url.
	 * @private
	 */
	p._gatewayUrl /*String*/ = null  ;

	/**
	 * Internal isProxy value.
	 * @private
	 */
	p._isProxy /*Boolean*/ = false ;

	/**
	 * Internal method name.
	 * @private
	 */
	p._methodName /*String*/ = null ; 
	
	/**
	 * Internal connection.
	 * @private
	 */
	p._rc /*RemotingConnection*/ = null ;

	/**
	 * Internal resolve delegation.
	 * @private
	 */
	p.__resolve = null ;

	/**
	 * Internal result.
	 * @private
	 */
	p._result = null ;

	/**
	 * Internal service name.
	 * @private
	 */
	p._serviceName /*String*/ = null ;
	
	/**
	 * Internal responder.
	 * @private
	 */
	p._responder /*RemotingServiceResponder*/ = null ;

	/**
	 * If the RemotingService is proxy, use this method to receive remote methods and call this methods.
	 * @private
	 */
	p.__resolve__ = function ( methodName /*String*/ ) /*Function*/ 
	{
		
		var rc /*RemotingConnection*/ = this._rc ;
		
		if ( rc == null ) 
		{
			// ici notifier qu'il est impossible de lancer la connection.	
			return null ;
		}
		
		if( methodName == "__path__") 
		{
			return null ; // hack pour le toString avec ConstructorUtil.getName !!
		}
		
		var responder /*RemotingServiceResponder*/ = this.getResponder() ;
		responder.setMethodName(methodName) ;
		
		var serviceName /*String*/ = this._serviceName ;

		return function () 
		{
			var args /*Array*/ = [ serviceName + "." + methodName , responder ].concat( Array.fromArguments(arguments)) ;
			return rc.call.apply( rc, args ); 
		} ;
		
	}
	
	/**
	 * Invoqued when the status of the connection change.
	 * @private
	 */
	p._onStatus = function ( ev /*Object*/ ) /*void*/ 
	{
		if (ev.level == asgard.net.remoting.RemotingService.LEVEL_ERROR) 
		{
			this.notifyError(ev.code) ;
		}
	}

	/**
	 * Encapsulate
	 */
 	delete p ;
 
}
