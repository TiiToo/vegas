/*

  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at 
  
           http://www.mozilla.org/MPL/ 
  
  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the License. 
  
  The Original Code is Vegas Framework.
  
  The Initial Developer of the Original Code is
  ALCARAZ Marc (aka eKameleon)  <vegas@ekameleon.net>.
  Portions created by the Initial Developer are Copyright (C) 2004-2007
  the Initial Developer. All Rights Reserved.
  
  Contributor(s) :
  
*/

// TODO finish Unit Tests.
// TODO see to implement this class with AbstractCoreEventDispatcher ?

/**
 * The NetServerConnection class.  
 * <p><b>Example :</b></p>
 * {@code
 * 
 * Delegate = vegas.events.Delegate ;
 * 
 * NetServerEvent = asgard.events.NetServerEvent ;
 * NetServerInfo = asgard.net.NetServerInfo ;
 * NetServerStatus = asgard.net.NetServerStatus ;
 * NetServerConnection = asgard.net.NetServerConnection ;
 * 
 * // ---- Callbacks
 * 
 * function onClose( e )
 * {
 *      trace("> " + e.getType()) ;
 * }
 * 
 * function onFinish( e )
 * {
 *     trace("> " + e.getType()) ;
 * }
 * 
 * function onStart( e )
 * {
 *      trace("> " + e.getType()) ;
 * }
 * 
 * function onStatus( e )
 * {
 *     var type  = e.getType() ;
 *     var target = e.getTarget() ;
 *     var status  = e.getStatus() ;
 *     var info  = e.getInfo() ;
 * 
 *     trace("> " + e.getType() + " : " + status) ;
 * 
 *     switch (info)
 *     {
 *         case NetServerStatus.SUCCESS :
 *         {
 *             //
 *             break ;
 *         }
 * 
 *         case NetServerStatus.BAD_VERSION :
 *         {
 *             //
 *             break ;
 *         }
 * 
 *         case NetServerStatus.CLOSED :
 *         {
 *             //
 *             break ;
 *         }
 *         
 *         case NetServerStatus.FAILED :
 *         {
 *              trace(" >> " + info.code) ;
 * 				trace(" >> " + info.level) ;
 * 				trace(" >> " + info.description) ;
 * 				break ;
 *         }
 * 
 *         case NetServerStatus.INVALID :
 *         {
 *             //
 *             break ;
 *         }
 * 
 * 		   case NetServerStatus.REJECTED :
 *         {
 *             //
 *             break ;
 *         }
 *
 *         case NetServerStatus.SHUTDOWN :
 *         {
 *             //
 *             break ;
 *         }
 *     }
 * }
 * 
 * function onTimeOut( e )
 * {
 *      var type = e.getType() ;
 *      var target = e.getTarget() ;
 *      trace("> " + e.getType()) ;
 * }
 * 
 * // ---- Test Connection
 * 
 * var co = new NetServerConnection() ;
 * co.addEventListener( NetServerEvent.CLOSE , new Delegate(this, onClose) ) ;
 * co.addEventListener( NetServerEvent.FINISH , new Delegate(this, onFinish) ) ;
 * co.addEventListener( NetServerEvent.START , new Delegate(this, onStart) ) ;
 * co.addEventListener( NetServerEvent.NET_STATUS, new Delegate(this, onStatus) ) ;
 * co.addEventListener( NetServerEvent.TIMEOUT, new Delegate(this, onTimeOut) ) ;
 * 
 * var url = "rtmp://127.0.0.1/test" ;
 * co.connect( url ) ;
 */
if (asgard.net.NetServerConnection == undefined) 
{
	
	/**
	 * @requires asgard.events.NetServerEven
	 */
	require("asgard.events.NetServerEvent") ;

	/**
	 * @requires asgard.net.NetServerInfo
	 */
	require("asgard.net.NetServerInfo") ;

	/**
	 * @requires asgard.net.NetServerStatus
	 */
	require("asgard.net.NetServerStatus") ;
	
	/**
	 * Creates a new NetServerConnection instance.
	 * @param bGlobal the flag to use a global event flow or a local event flow.
	 * @param sChannel the name of the global event flow if the {@code bGlobal} argument is {@code true}.
	 */
	asgard.net.NetServerConnection = function( bGlobal /*Boolean*/ , sChannel /*String*/ ) 
	{
		
		vegas.events.AbstractCoreEventDispatcher.call(this, bGlobal, sChannel) ;

		this.initEvent() ;
				
		this._nc = new NetConnection() ;
		this._nc.onStatus = vegas.events.Delegate.create(this, this._onStatus) ;
		
		this._timer = new vegas.util.Timer(8000, 1) ;
		this._timeOut = new vegas.events.Delegate(this, this._onTimeOut) ;
		
	}
	
	/**
	 * @extends vegas.events.AbstractCoreEventDispatcher
	 */
	proto = asgard.net.NetServerConnection.extend( vegas.events.AbstractCoreEventDispatcher ) ;
 
	/**
	 * This method is overrides if you want receive Events from the server.
	 * @see NetServerGateway
	 */
	proto.receiveSharedEvent /*Function*/ = null ;

	/**
	 * Adds a context header to the AMF packet structure.
	 * @param name A string; identifies the header and the ActionScript object data associated with it.
	 * @param useUnderstand A Boolean value; true indicates that the server must understand and process this header before it handles any of the following headers or messages.
	 * @param value Any ActionScript object.
	 */
	asgard.net.NetServerConnection.prototype.addHeader = function ( name /*String*/ , useUnderstand /*Boolean*/, value /*Object*/ ) /*void*/
	{
		this._nc.addHeader.call( this._nc, name, useUnderstand, value ) ;
	}
	
	/**
	 * Invokes a command or method on a Flash Media Server or an application server to which the application instance is connected. 
	 * The NetConnection.call method on the server works the same way as the NetConnection.call method on the client: it invokes a command on a remote server.
	 * @param resultObj An optional parameter that is used to handle return values from the server. 
	 * The result object can be any object you defined and can have two defined methods to handle the returned result: onResult and onStatus. 
	 * If an error is returned as the result, onStatus is invoked; otherwise, onResult is invoked. 
	 * @param methodName A method specified in the form [objectPath/]method.
	 * @param p1, ..., pN Optional parameters that can be of any ActionScript type, including a reference to another ActionScript object. 
	 * These parameters are passed to the methodName specified above when the method is executed on the remote application server.
	 * @return For RTMP connections, returns a Boolean value of true if a call to methodName is sent to the client ; otherwise, false. 
	 * For application server connections, it always returns true.
	 */
	asgard.net.NetServerConnection.prototype.call = function ( /* ...arguments */ ) /*Boolean*/ 
	{
		return this._nc.call.apply( this._nc, Array.fromArguments(arguments) ) ;
	}

	/**
	 * Returns the shallow copy of this object.
	 * @return the shallow copy of this object.
	 */
	proto.clone = function () /*NetServerConnection*/ 
	{
		return new asgard.net.NetServerConnection() ;	
	}

	/**
	 * Close the connection.
	 * @param noEvent if this argument is {@code true} the event propagation is disabled.
	 */
	/*override*/ proto.close = function ( noEvent /*Boolean*/ ) /*Void*/ 
	{
		this._nc.close() ;
		this._timer.stop() ;
		if (!noEvent) 
		{
			this.notifyClose() ;
		}
	}

	/**
	 * Connect the client with this method.
	 */
	/*override*/ proto.connect = function( uri )  
	{
		if ( this.isConnected )
		{
			return false ;
		}
		this.notifyStarted() ;
		this.setUri(uri) ;
		return this._nc.connect.apply( this._nc, Array.fromArguments(arguments)  ) ;
	}
	
	/**
	 * Returns and creates a new empty ModelObjectEvent. You can override this method.
	 * @param type the type of the event.
	 * @return a new empty ModelObjectEvent with the type specified in argument.
	 */
	proto.createNewEvent = function ( type /*String*/ ) /*NetServerEvent*/ 
	{
		return new asgard.events.NetServerEvent( type || null , this ) ;
	}

	/**
	 * Returns the timeout interval duration.
	 * @return the timeout interval duration.
	 */
	proto.getDelay = function () /*Number*/ 
	{
		return _timer.getDelay() ;	
	}

	/**
	 * Returns the event name use in the connection is closed.
	 * @return the event name use in the connection is closed.
	 */
	proto.getEventTypeCLOSE = function() /*String*/
	{
		return this._eClose.getType() ;
	}

	/**
	 * Returns the event name use in the connection is finished.
	 * @return the event name use in the connection is finished.
	 */
	proto.getEventTypeFINISH = function() /*String*/
	{
		return this._eFinish.getType() ;
	}
	
	/**
	 * Returns the event name use in the connection is started.
	 * @return the event name use in the connection is started.
	 */
	proto.getEventTypeSTART = function() /*String*/
	{
		return this._eStart.getType() ;
	}
	
	/**
	 * Returns the event name use in the connection status changed.
	 * @return the event name use in the connection status changed.
	 */
	proto.getEventTypeSTATUS = function() /*String*/
	{
		return this._eStatus.getType() ;
	}

	/**
	 * Returns the event name use in the connection is out of time.
	 * @return the event name use in the connection is out of time.
	 */
	proto.getEventTypeTIMEOUT = function() /*String*/
	{
		return this._eTimeOut.getType() ;
	}
	
	/**
	 * Returns a Boolean value indicating whether a connection has been made (true) or not (false).
	 * @return a Boolean value indicating whether a connection has been made (true) or not (false).
	 */
	asgard.net.NetServerConnection.prototype.getIsConnected = function () /*Boolean*/ 
	{
		return this._nc.isConnected ;	
	}

	/**
	 * Returns the NetServerPolicy value of this object.
	 * @return the NetServerPolicy value of this object.
	 * @see NetServerPolicy
	 */
	proto.getLimitPolicy = function () /*NetServerPolicy*/ 
	{
		return this._policy ;	
	}

	/**
	 * Returns The URI that the NetConnection.connect() method passed.
	 * @return The URI that the NetConnection.connect() method passed.
	 */
	asgard.net.NetServerConnection.prototype.getUri = function () /*String*/ 
	{
		return this._uri || this._nc.uri ;
	}

	/**
	 * This method is invoqued in the constructor of the class to initialize all events.
	 * Overrides this method.
	 */
	proto.initEvent = function() /*void*/
	{
		NetServerEvent = asgard.events.NetServerEvent ;
		this._eClose   = this.createNewEvent( NetServerEvent.CLOSE      ) ;
		this._eFinish  = this.createNewEvent( NetServerEvent.FINISH     ) ;
		this._eStart   = this.createNewEvent( NetServerEvent.START      ) ;
		this._eStatus  = this.createNewEvent( NetServerEvent.NET_STATUS ) ;
		this._eTimeOut = this.createNewEvent( NetServerEvent.TIMEOUT    ) ;
	}

	/**
	 * Invoqued when the connection is closed.
	 */
	proto.notifyClose = function() /*void*/ 
	{
		this.dispatchEvent( this._eClose ) ;	
	}

	/**
	 * Invoqued when the connection is finished.
	 */
	proto.notifyFinished = function() /*void*/ 
	{
		this.dispatchEvent( this._eFinish ) ;
	}

	/**
	 * Invoqued when the connection is started.
	 */
	proto.notifyStarted = function() /*void*/ 
	{
		this.dispatchEvent( this._eStart ) ;
	}
	
	/**
	 * Invoqued when the status of the connection is changed.
	 */
	proto.notifyStatus = function( status /*NetServerStatus*/ , info ) /*void*/ 
	{
		this._eStatus.setInfo(info) ;
		this._eStatus.setStatus(status) ;
		this.dispatchEvent( this._eStatus ) ;	
	}

	/**
	 * Invoqued when the connection is timeout.
	 */
	proto.notifyTimeOut = function() /*void*/ 
	{
		this.dispatchEvent( this._eTimeOut ) ;	
	}
	
	/**
	 * Runs the process of this NetServerConnection.
	 */
	proto.run = function () /*Void*/ 
	{
		this.connect(this.uri) ;
	}
	
	/**
	 * Set timeout interval duration.
	 */
	proto.setDelay = function ( n /*Number*/ , useSeconds /*Boolean*/ ) /*Void*/ 
	{
		var t /*Number*/ = (n > 0) ? n : 0 ;
		if (useSeconds)
		{
			t = Math.round(t * 1000) ;
		}
		this._timer.setDelay(t) ;
	}

	/**
	 * Sets the event name use in the connection is closed.
	 */
	proto.setEventTypeCLOSE = function( type /*String*/ ) /*void*/
	{
		this._eClose.setType( type ) ;
	}

	/**
	 * Sets the event name use in the connection is finished.
	 */
	proto.setEventTypeFINISH = function( type /*String*/ ) /*void*/
	{
		this._eFinish.setType( type ) ;
	}
	
	/**
	 * Sets the event name use in the connection is started.
	 */
	proto.setEventTypeSTART = function( type /*String*/ ) /*void*/
	{
		this._eStart.setType( type ) ;
	}
	
	/**
	 * Sets the event name use in the connection status changed.
	 */
	proto.setEventTypeSTATUS = function( type /*String*/ ) /*void*/
	{
		this._eStatus.setType( type ) ;
	}

	/**
	 * Sets the event name use in the connection is out of time.
	 */
	proto.setEventTypeTIMEOUT = function( type /*String*/ ) /*void*/
	{
		this._eTimeOut.setType( type ) ;
	}

	/**
	 * Sets if the connection use the limit timeout interval.
	 * @param policy the TimeoutPolicy.INFINITY or TimeoutPolicy.LIMIT values.
	 * @see TimeoutPolicy
	 */
	proto.setLimitPolicy = function ( policy /*TimeoutPolicy*/ ) /*Void*/ 
	{
		this._policy = policy ;
		
		if (this._policy == asgard.net.TimeoutPolicy.LIMIT) 
		{
			this._timer.addEventListener( vegas.events.TimerEventType.TIMER, this._timeOut) ;
		}
		else 
		{
			this._timer.removeEventListener(vegas.events.TimerEventType.TIMER, this._timeOut) ;
		}
	}

	/**
	 * Sets the default URI that the NetConnection.connect() method passed.
	 */
	asgard.net.NetServerConnection.prototype.setUri = function ( uri /*String*/ ) /*void*/ 
	{
		this._uri = uri ;
	}

	/**
	 * Use this method to dispatch in FMS application an event.
	 */
	proto.sharedEvent = function ( event , context ) /*Void*/ 
	{
		var eventType /*String*/ ;
		if (event instanceof vegas.events.Event) 
		{
			this.call(event, null, event) ;
		}
		else if (vegas.util.TypeUtil.typesMatch( event, String ) ) 
		{
			this.call( event, null, context || null ) ;
		}
	}
	
	/**
	 * Returns the string Eden representation of this object.
	 * @return the string Eden representation of this object.
	 */
	proto.toSource = function () /*String*/ 
	{
		return "new asgard.net.NetServerConnection()" ;
	}
	
	proto.toString = function () /*String*/ 
	{
		return "[" + vegas.util.ConstructorUtil.getName(this) + "]" ;
	}
	
	/**
	 * (read-only) A Boolean value indicating whether a connection has been made (true) or not (false).
	 */
	vegas.util.factory.PropertyFactory.create( proto, "isConnected", true) ;

	/**
	 * (read-write) the URI that the NetConnection.connect() method passed.
	 */
	vegas.util.factory.PropertyFactory.create( proto, "uri") ;

	/**
	 * @private
	 */
	proto._eClose /*NetServerEvent*/ = null ;

	/**
	 * @private
	 */
	proto._eFinish /*NetServerEvent*/ = null ;

	/**
	 * @private
	 */
	proto._eStart /*NetServerEvent*/= null ;

	/**
	 * @private
	 */
	proto._eStatus /*NetServerEvent*/ = null  ;

	/**
	 * @private
	 */
	proto._eTimeOut /*NetServerEvent*/ = null ;

	/**
	 * @private
	 */
	proto._isGlobal /*Boolean*/ = null ;

	/**
	 * @private
	 */
	proto._policy /*TimeoutPolicy*/ = null ;

	/**
	 * @private
	 */
	proto._timer /*Timer*/ = null ;

	/**
	 * @private
	 */
	proto._timeOut /*EventListener*/ = null ;

	/**
	 * @private
	 */
	proto._uri /*String*/ = null ;

	/**
	 * @private
	 */
	proto._onStatus = function ( oInfo ) /*Void*/ 
	{
		
		if (this.getLogger() != null)
		{
			this.getLogger().info( this + " onStatus : " + oInfo.code + " " + oInfo.description ) ;
		}
		
		this._timer.stop() ;
		
		var NetServerStatus = asgard.net.NetServerStatus ;

		if (oInfo.code == null) 
		{
			return ;
		}
				
		var code /*NetServerStatus*/ = NetServerStatus.format(oInfo.code) ;
		
		switch (code) 
		{
		
			case NetServerStatus.BAD_VERSION :
			{
				this.notifyStatus(NetServerStatus.BAD_VERSION) ;
				break ;
			}
			case NetServerStatus.CLOSED :
			{
				this.notifyStatus(NetServerStatus.CLOSED) ;
				break ;
			}
			case NetServerStatus.FAILED :
			{
				this.notifyStatus(NetServerStatus.FAILED, oInfo) ;
				break ;
			}
			case NetServerStatus.INVALID :
			{
				this.notifyStatus(NetServerStatus.INVALID) ;
				break ;
			}	
			case NetServerStatus.REJECTED :
			{
				this.notifyStatus(NetServerStatus.REJECTED) ;
				break ;
			}
			case NetServerStatus.SHUTDOWN :
			{
				this.notifyStatus(NetServerStatus.SHUTDOWN) ;
				break ;
			}
			case NetServerStatus.SUCCESS :
			{
				this.notifyStatus(NetServerStatus.SUCCESS) ;
				break ;
			}
		}
		this.notifyFinished() ;
	}

	proto._onTimeOut = function ( e /*TimerEvent*/ ) /*Void*/
	{
		this.notifyTimeOut() ;
		this.notifyFinished() ;
		this.close() ;
	}

	delete proto ;

}
