/*

  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at 
  
           http://www.mozilla.org/MPL/ 
  
  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the License. 
  
  The Original Code is Vegas Framework.
  
  The Initial Developer of the Original Code is
  ALCARAZ Marc (aka eKameleon)  <vegas@ekameleon.net>.
  Portions created by the Initial Developer are Copyright (C) 2004-2007
  the Initial Developer. All Rights Reserved.
  
  Contributor(s) :
  
*/

/**
 * This class encapsulate the SSAS Application class who contains information about a Flash Media Server application instance 
 * that lasts until the application instance is unloaded.
 * <p><b>Example :</b></p>
 * {@code
 * onAccept = function ( e )
 * {
 *     trace( e ) ;
 * }
 * 
 * onConnect = function ( e )
 * {
 *     trace( e ) ;
 *     asgard.APPLICATION.acceptConnection( e.client ) ;
 *     asgard.APPLICATION.rejectConnection( e.client , "test reject") ;
 * }
 * 
 * onDisconnect = function ( e )
 * {
 *     trace( e ) ;
 * }
 * 
 * onReject = function ( e )
 * {
 *     trace( e ) ;
 * }
 * 
 * onStart = function ( e )
 * {
 *     trace( e ) ;
 * }
 * 
 * onStop = function ( e )
 * {
 *     trace( e ) ;
 * }
 * 
 * ApplicationEvent = asgard.events.ApplicationEvent ;
 * Delegate         = vegas.events.Delegate ;
 * 
 * controller = vegas.events.FrontController.getInstance() ;
 * 
 * controller.insert( ApplicationEvent.ACCEPT     , new Delegate  (this, onAccept)) ;
 * controller.insert( ApplicationEvent.CONNECT    , new Delegate  (this, onConnect)) ;
 * controller.insert( ApplicationEvent.DISCONNECT , new Delegate  (this, onDisconnect)) ;
 * controller.insert( ApplicationEvent.REJECT     , new Delegate  (this, onReject)) ;
 * controller.insert( ApplicationEvent.START      , new Delegate  (this, onStart)) ;
 * controller.insert( ApplicationEvent.STOP       , new Delegate  (this, onStop)) ;
 * 
 * asgard.APPLICATION.setGlobal(true) ; // link the application with the global event flow.
 * @author eKameleon
 */
if ( asgard.server.Application == undefined ) 
{

	/**
	 * @requires asgard.events.ApplicationEvent
	 */
	require("asgard.events.ApplicationEvent") ;

	/**
	 * Creates a new Application instance.
	 * @param bGlobal the flag to use a global event flow or a local event flow.
	 * @param sChannel the name of the global event flow if the {@code bGlobal} argument is {@code true}.
	 */
	asgard.server.Application = function ( bGlobal /*Boolean*/ , sChannel /*String*/ ) 
	{

		vegas.events.AbstractCoreEventDispatcher.call( this, bGlobal, sChannel ) ;
		
		if (asgard.GATEWAY != null) 
		{
			throw new vegas.errors.RuntimeError("asgard.server.Application constructor is private.") ;
		}

		this.logger = vegas.logging.Log.getLogger("asgard.server.Application") ;
		
		var ApplicationEvent = asgard.events.ApplicationEvent ;
		var Delegate         = vegas.events.Delegate ;
		
		application.onAppStart   = Delegate.create( this, this._onAppStart ) ;
		application.onAppStop    = Delegate.create( this, this._onAppStop ) ;
		application.onConnect    = Delegate.create( this, this._onConnect ) ;
		application.onDisconnect = Delegate.create( this, this._onDisconnect ) ;
		
		this._eAccept     = new ApplicationEvent( ApplicationEvent.ACCEPT     , this ) ;
		this._eConnect    = new ApplicationEvent( ApplicationEvent.CONNECT    , this ) ;
		this._eDisconnect = new ApplicationEvent( ApplicationEvent.DISCONNECT , this ) ;
		this._eReject     = new ApplicationEvent( ApplicationEvent.REJECT     , this ) ;
		this._eStart      = new ApplicationEvent( ApplicationEvent.START      , this ) ;
		this._eStop       = new ApplicationEvent( ApplicationEvent.STOP       , this ) ;
	}

	/**
	 * @extends vegas.events.AbstractCoreEventDispatcher
	 */
	proto = asgard.server.Application.extend( vegas.events.AbstractCoreEventDispatcher ) ;

	/**
	 * Accepts the connection call from a client to the server. 
	 */
	proto.acceptConnection = function ( client ) 
	{
		try 
		{
			if (client != null) 
			{
				this.notifyAccept(client) ;
			} 
			else
			{
				throw new vegas.errors.IllegalArgumentError("Application.acceptConnection 'client' not must be 'null' or 'undefined'.") ;
			}
		}
		catch(e) 
		{
			this.logger.error( e.toString() ) ;
		}
	}

	/**
	 * Returns the accept event type name.
	 * @return the accept event type name.
	 */
	proto.getEventTypeACCEPT = function () /*String*/
	{
		return this._eAccept.getType() ;
	}
	
	/**
	 * Returns the connect event type name.
	 * @return the connect event type name.
	 */
	proto.getEventTypeCONNECT = function () /*String*/
	{
		return this._eConnect.getType() ;
	}
	
	/**
	 * Returns the disconnect event type name.
	 * @return the disconnect event type name.
	 */
	proto.getEventTypeDISCONNECT = function () /*String*/
	{
		return this._eConnect.getType() ;
	}
	
	/**
	 * Returns the reject event type name.
	 * @return the reject event type name.
	 */
	proto.getEventTypeREJECT = function () /*String*/
	{
		return this._eReject.getType() ;
	}

	/**
	 * Returns the start event type name.
	 * @return the start event type name.
	 */
	proto.getEventTypeSTART = function () /*String*/
	{
		return this._eStart.getType() ;
	}
	
	/**
	 * Returns the stop event type name.
	 * @return the stop event type name.
	 */
	proto.getEventTypeSTOP = function () /*String*/
	{
		return this._eStop.getType() ;
	}
	
	/**
	 * Notify if a client is accepted.
	 */
	proto.notifyAccept = function ( client /*Client*/ ) /*void*/ 
	{
		
		if (client == null) 
		{
			return ;
		}
		
		application.acceptConnection( client ) ;
		
		this._eAccept.setClient( client ) ;
		this._eAccept.setContext( client.__ARGUMENTS__ ) ;
		this.dispatchEvent( this._eAccept ) ;
		
	}	

	/**
	 * Notify the connection of a client.
	 */
	proto.notifyConnect = function ( client /*Client*/ , context /*Object*/ ) /*void*/
	{
		this._eConnect.setClient( client ) ;
		this._eConnect.setContext( context ) ;
		this.dispatchEvent( this._eConnect ) ;
	}
	
	/**
	 * Notify the disconnection of a client.
	 */
	proto.notifyDisconnect = function ( client /*Client*/ ) /*void*/
	{
		this._eDisconnect.setClient( client ) ;
		this.dispatchEvent( this._eDisconnect ) ;
	}
	
	/**
	 * Notify the reject connection of a client.
	 */
	proto.notifyReject = function ( client /*Client*/ , error ) /*void*/ 
	{
		
		if (client == null) 
		{
			return ;
		}
		
		if ( client.__ERROR__ == null ) 
		{
			application.rejectConnection( client , error ) ;
		}
		else 
		{
			application.rejectConnection( client , client.__ERROR__ ) ;
		}
		
		var ApplicationEvent = asgard.events.ApplicationEvent ;
		
		
		this._eReject.setClient( client ) ;
		this.dispatchEvent( this._eReject ) ;
		
	}

	/**
	 * Notify the start of the server.
	 */
	proto.notifyStart = function ( info ) /*void*/ 
	{
		
		this.dispatchEvent( this._eStart ) ;
	}

	/**
	 * Notify the stop of the server.
	 */
	proto.notifyStop = function ( info ) /*void*/ 
	{
		
		this._eStop.setInfo( info )
		this.dispatchEvent( this._eStop ) ;
	}
	
	/**
	 * Reject the connection of a client.
	 */
	proto.rejectConnection = function ( client /*Client*/ , error ) /*void*/ 
	{
		try 
		{
			if (client != null) 
			{
				this.notifyReject(client , error ) ;
			} 
			else
			{
				throw new vegas.errors.IllegalArgumentError("Application.rejectConnection 'client' not must be 'null' or 'undefined'.") ;
			}
		}
		catch(e) 
		{
			this.logger.error ( e.toString() ) ;
		}
	}
	
	/**
	 * Sets the accept event type name.
	 * @param type The name of the event to set.
	 */
	proto.setEventTypeACCEPT = function ( type /*String*/ ) /*void*/
	{
		this._eAccept.setType( type ) ;
	}

	/**
	 * Sets the connect event type name.
	 * @param type The name of the event to set.
	 */
	proto.setEventTypeCONNECT = function ( type /*String*/ ) /*void*/
	{
		this._eConnect.setType( type ) ;
	}

	/**
	 * Sets the disconnect event type name.
	 * @param type The name of the event to set.
	 */
	proto.setEventTypeDISCONNECT = function ( type /*String*/ ) /*void*/
	{
		this._eDisconnect.setType( type ) ;
	}

	/**
	 * Sets the reject event type name.
	 * @param type The name of the event to set.
	 */
	proto.setEventTypeREJECT = function ( type /*String*/ ) /*void*/
	{
		this._eReject.setType( type ) ;
	}
	
	/**
	 * Sets the start event type name.
	 * @param type The name of the event to set.
	 */
	proto.setEventTypeSTART = function ( type /*String*/ ) /*void*/
	{
		this._eStart.setType( type ) ;
	}

	/**
	 * Sets the stop event type name.
	 * @param type The name of the event to set.
	 */
	proto.setEventTypeSTOP = function ( type /*String*/ ) /*void*/
	{
		this._eStop.setType( type ) ;
	}

	/**
	 * Invoqued if the application start.
	 * @private
	 */
	proto._onAppStart = function () /*void*/
	{
		this.notifyStart() ;
	}
	
	/**
	 * Invoqued if the application stop.
	 * @private
	 */
	proto._onAppStop = function ( info ) /*void*/
	{
		this.notifyStop( info ) ;
	}

	/**
	 * Invoqued if a client is connected.
	 * @private
	 */
	proto._onConnect = function ( client /*Client*/ ) /*void*/
	{
		
		client.__ID__ = client.hashCode() ;
		
		var args = (arguments.length > 0) ? Array.fromArguments(arguments) : null ;
		
		client.__ARGUMENTS__ = args ;
		
		client.__RESPONSE__ = new vegas.data.map.HashMap() ;
		
		client.__PROCESSING__ = true ;
		
		var context = (args.length > 1) ? [].concat(args) : null ;
		if (context != null) 
		{
			context.shift() ;	
		}
		
		this.notifyConnect( client, context ) ;
		
		client.__PROCESSING__ = false ;
		
	}

	/**
	 * Invoqued if a client is disconnected.
	 * @private
	 */
	proto._onDisconnect = function ( client /*Client*/ ) /*void*/
	{
		this.notifyDisconnect(client) ;
	}
	
	/**
	 * Singleton
	 */
	asgard.APPLICATION = new asgard.server.Application() ;
	
}