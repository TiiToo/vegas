/*

  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at 
  
           http://www.mozilla.org/MPL/ 
  
  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the License. 
  
  The Original Code is Vegas Framework.
  
  The Initial Developer of the Original Code is
  ALCARAZ Marc (aka eKameleon)  <vegas@ekameleon.net>.
  Portions created by the Initial Developer are Copyright (C) 2004-2005
  the Initial Developer. All Rights Reserved.
  
  Contributor(s) :
  
*/

/** Range
 
	AUTHOR
	
		Name : Range
		type : SSAS
		Package : vegas.maths
		Version : 1.0.0.0
		Date :  2006-05-29
		Author : ekameleon
		URL : http://www.ekameleon.net
		Mail : contact@ekameleon.net

	USE
	
		load("src/vegas.asc") ;
		
		var r1 = new vegas.maths.Range( 25 , 50 ) ;
		var r2 = new vegas.maths.Range( 40 , 100 ) ;
		
		var clone = r1.clone() ;
		
		trace("r1 clamp 10 : " + r1.clamp(10)) ;
		trace("r1 clamp 60 : " + r1.clamp(60)) ;
		trace("r1 clamp 0 : " + r1.clamp(0)) ;
		// trace("r1 clamp null : " + r1.clamp(null)) ; // IllegalArgumentError
		
		trace("r1 contains 12 : " + r1.contains(12)) ;
		trace("r1 contains 30 : " + r1.contains(30)) ;
		
		trace("r1 equals clone : " + r1.equals(clone)) ;
		
		trace("r1 isOutOfRange r2 : " + r1.isOutOfRange(r2)) ;
		trace("r1 overlap r2 : " + r1.overlap(r2)) ;
		
		trace("r1.toSource : " + r1.toSource()) ;
		trace("r1.toString : " + r1.toString()) ;

	CONSTRUCTOR
	
		var r:Range = new vegas.maths.Range(p_min:Number, p_max:Number) ;
	
	CONSTANT SUMMARY
	
		- PERCENT_RANGE : Range between 0 and 100
		
		- COLOR_RANGE : Range between -255 and 255
	
	PROPERTY SUMMARY
		
		- max:Number
			
		- min:Number

	METHOD SUMMARY

		- clamp(value:Number):Number
		
		- clone()
		
		- contains(value):Boolean
		
		- equals(o):Boolean
		
		- isOutOfRange(value:Number):Boolean
		
		- overlap(r:Range):Boolean
		
			test si les 2 objets de type Range se chevauchent.
		
		- toSource():String
		
		- toString():String

	INHERIT
	
		CoreObject â†’ Range

	IMPLEMENTS

		ICloneable, IEquality, ISerializable, IFormattable
 
**/
 
_global.getPackage("vegas.maths") ;

if (vegas.maths.Range == undefined) {
	
	// ----o Imports
	
	loadFile("vegas/core/CoreObject.asc") ;
	loadFile("vegas/util/MathsUtil.asc") ;
	
	// ----o Constructor
 
	vegas.maths.Range = function( p_min /*Number*/ , p_max /*Number*/ ) {
		if (p_max < p_min) throw new vegas.errors.ArgumentOutOfBoundsError("Range constructor, 'max' argument is < of 'min' argument") ;
		this.min = p_min ;
		this.max = p_max ;
	}

	// ---- INHERIT
 
	var constructor = vegas.maths.Range ;
	var proto = constructor.extend(vegas.core.CoreObject) ;
 
 	// ----o Constant
	
	constructor.PERCENT_RANGE /*Range*/ = new vegas.maths.Range(0, 100) ;
	
	constructor.COLOR_RANGE /*Range*/ = new vegas.maths.Range(-255, 255) ;
	
 	// ----o Public Methods
 
 	proto.clamp = function ( value /*Number*/ ) /*Void*/ {
		return vegas.util.MathsUtil.clamp(value, this.min, this.max) ;
	}

	proto.clone = function () {
		return new vegas.maths.Range(this.min, this.max) ;
	}

	proto.contains = function (value /*Number*/) /*Boolean*/ {
		return !this.isOutOfRange(value) ;
	}
	
	proto.equals = function (o) /*Boolean*/ {
		return (o instanceof vegas.maths.Range) 
					&& (o.min == this.min) 
						&& (o.max == this.max) ; 
	}

	proto.isOutOfRange = function (value /*Number*/) {
		return (value > this.max ) || (value < this.min) ;
	}

	proto.overlap = function ( r /*Range*/ ) /*Boolean*/ {
		return (this.max > r.min) && (r.max > this.min) ;
	}
	
	proto.toSource = function (indent/*Number*/, indentor/*String*/)/*String*/ {
		return "new Range(" + this.min + "," + this.max + ")";
	}

	proto.toString = function () /*String*/ {
		return "<" + this.min + "," + this.max + ">";
	}

	// ----o Private Properties
	
	proto.max /*Number*/ = null ;
	
	proto.min /*Number*/ = null ;

	// ----o Encapsulate
 
	delete constructor ;
	delete proto ;

}
