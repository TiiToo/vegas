/*

  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at 
  
           http://www.mozilla.org/MPL/ 
  
  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the License. 
  
  The Original Code is Vegas Framework.
  
  The Initial Developer of the Original Code is
  ALCARAZ Marc (aka eKameleon)  <vegas@ekameleon.net>.
  Portions created by the Initial Developer are Copyright (C) 2004-2005
  the Initial Developer. All Rights Reserved.
  
  Contributor(s) :
  
*/

/** UnicodeChar

	AUTHOR

		Name : WildExp
		type : SSAS
		Package : vegas.events
		Version : 1.0.0.0
		Author : ekameleon
		Date : 2006-05-31
		URL : http://www.ekameleon.net
		Mail : vegas@ekameleon.net

	DESCRIPTION
		
		A wild expression is constructed like a regular expression but is based 
		on a globbing algorithm like the one you found for searching files on a hard-drive.
	
	CONSTANT SUMMARY
	
		- IGNORECASE
		
		- MULTILINE
		
		- MULTIWORD
		
		- NONE
	
	PROPERTY SUMMARY
	
		- questionsMarks:Array
		
		- source:String
		
		- wildcards:Array
	
	METHOD SUMMARY
	
		- addToQuestionMarks(chr:String):Void
		
		- addToWildcards(chr:String):Void
		
		- test(str:String)
	
	SYNTAX
	
		1. ? : match any unique char - exactly 1 char must be found
		2. * : match any number of chars - at least 0 or more any chars can be found
		3. ! : ignore next char
	
	RULES :
	
		1. "*" is equal to "**" to "***" to an infinity number of "*" chars      
		2. "*?" is concatened to "*" (more precisely "*?*")
		3. "*" if for zero char to infinity chars
		4. "!*" ignore the pattern and look for the char "*" in string
		4. "!?" ignore the pattern and look for the char "?" in string
	
	TIPS AND TRICKS :
		
		var WildExp = vegas.string.WildExp ;
		
		// find all the words in a string
			
			var we = new WildExp( "*", WildExp.IGNORECASE | WildExp.MULTIWORD );
			result = we.test( "any phrases with words inside" );
			trace(result) ;
			//result = [ "any", "phrases", "with", "words", "inside" ];
		
		// find comments in a string
			var we = new WildExp( "*\/!**!*!/\*", WildExp.IGNORECASE | WildExp.MULTIWORD );
			result = we.test( "toto = \"123\"; /\*hello world*\/" );
			trace(result) ;
			//result = [ "toto = \"123\"; ", "hello world" ] ;
      
		// find the name, arguments and body of a function
			var we = new WildExp( "function *(*)*{*}", WildExp.IGNORECASE | WildExp.MULTIWORD );
			result = we.test( "function toto( a, b, c )\r\n{\treturn \"hello world\";\r\n\t}" );
			trace(result) ;
			//result = [ "toto", " a, b, c ", "\r\n", "\treturn \"hello world\";\r\n\t" ];
      

	THANKS
		
		Zwetan : Flashcodeurs mailing list [FMX] WildExp 2004/11/23
		J'ai juste traduis la classe de Zwetan en AS2 ^_^ 
		Les commentaires au dessus sont aussi de Zwetan. 

	SEE ALSO
	
		- String.replace()
		- vegas.string.UnicodeChar : WHITE_SPACE_CHARS and LINE_TERMINATOR_CHARS constants

**/ 

// TODO Attention classe SUPER INSTABLE !!!!!!!

_global.getPackage("vegas.string") ;

if (vegas.string.WildExp == undefined) {
	
	/* CORE 2 HACK ??? */
	
	String.prototype.replace = function( oldValue /*String*/, newValue /*String*/) {
		return this.split( oldValue ).join( newValue );
	}

	/* CORE 2 HACK !!! */

	// ----o Imports
	
	loadFile("vegas/core/CoreObject.asc") ;
	loadFile("vegas/string/UnicodeChar.asc") ;
	
	// ----o Constructor

	vegas.string.WildExp = function( pattern /*String*/ , flag /*Number*/ ) {
		
		var WildExp = vegas.string.WildExp ;
		
		if( isNaN(flag) ) {
			flag = vegas.string.WildExp.NONE ;
		}
       
		this.wildcards = [] ;
		this.questionMarks = [] ;
		
		this._caseSensitive = true ;
		this._multiline = false ;
		this._multiword = false ;
		this._wildcardFound = false;
		this._questionMarksFound = false ;
    
		switch(flag) {
        	
			case WildExp.IGNORECASE : // 1
				this._caseSensitive = false ;
				break;
				
        	case WildExp.MULTILINE :
				this._multiline = true ; // 2
				break;
			
			case WildExp.IGNORECASE | WildExp.MULTILINE : //3
				this._caseSensitive = false ;
				this._multiline = true ;
				break ;
			
			case WildExp.MULTIWORD : // 4
				this._multiword = true ;
				break;
			
			case WildExp.IGNORECASE | WildExp.MULTIWORD : // 5
				this._caseSensitive = false ;
				this._multiword = true ;
				break ;
			
			case WildExp.MULTILINE | WildExp.MULTIWORD : // 6
				this._multiline = true ;
				this._multiword = true ;
				break;
				
			case WildExp.IGNORECASE | WildExp.MULTILINE | WildExp.MULTIWORD : // 7
				this._caseSensitive = false ;
				this._multiline = true ;
				this._multiword = true ;
				break ;
			
			case NONE : 
			default:
				//
        }
		
		if( this._caseSensitive ) {
			pattern = pattern.toLowerCase();
		}
        
		this.source = pattern ;
		
	}

	// -----o Inherit

	var constructor = vegas.string.WildExp ;
	var proto = constructor.extend(vegas.core.CoreObject) ;

	// -----o CONSTANT
	
	vegas.string.WildExp.NONE /*Number*/ = 0 ;
	
	vegas.string.WildExp.IGNORECASE /*Number*/ = 1 ;
	
	vegas.string.WildExp.MULTILINE /*Number*/ = 2 ;
	
	vegas.string.WildExp.MULTIWORD /*Number*/ = 4 ;

	// -----o Public Properties
	
	proto.wildcards /*Array*/ = null ;
	proto.questionMarks /*Array*/ = null ;
	proto.source /*String*/ = null ;

	// ----o Public Methods

	proto.addToQuestionMarks = function (chr /*String*/) /*Void*/ {
		var l /*Number*/ = this.questionMarks.length ;
		if( l == 0 ) {
			return ;
		}
		this.questionMarks[ l - 1 ] += chr ;
    }
	
	proto.addToWildcards = function (chr /*String*/) /*Void*/ {
		var l /*Number*/ = this.wildcards.length ;
		if( l == 0 ) {
			return ;
		}
		this.wildcards[l-1] += chr ;
    }

	proto.test = function (str /*String*/) {
		
		var UnicodeChar = vegas.string.UnicodeChar ;
		
		var segment, result, lineTerminatorChars, whiteSpaceChars /*Array*/ ;
		var result /*Array*/ ;
		var i, j, k, l /*Number*/ ;
		
		lineTerminatorChars = UnicodeChar.LINE_TERMINATOR_CHARS ;
		whiteSpaceChars = UnicodeChar.WHITE_SPACE_CHARS ; 
		
		var CRLF /*String*/ = "\r\n";
		var ORC /*String*/  = "\uFFFC";
		
		if( this._caseSensitive ) {
			str = str.toLowerCase();
		}
		
        if( this._multiline ) {
			
			if( str.indexOf( CRLF ) > -1 ) {
				str = str.replace(CRLF, ORC ) ; // Core2 String.replace method.
			}
			l = lineTerminatorChars.length ;
			for( i=0 ; i<l ; i++ ) {
				if( str.indexOf( lineTerminatorChars[i] ) > -1 ) {
					str = str.replace( lineTerminatorChars[i] , ORC ) ;
				}
            }
        }
		
		if( this._multiword ) {
			
			
			l = whiteSpaceChars.length ;
			
			for( j=0 ; j<l ; j++ ) {
				var index = str.indexOf( whiteSpaceChars[j] ) ;
				if( str.indexOf( whiteSpaceChars[j] ) > -1 ) {
					str = str.replace(whiteSpaceChars[j], ORC ) ;
				}
            }
			
        }
		
		if( str.indexOf( ORC ) > -1 ) {
			
			segment = str.split( ORC ) ;
			result = [] ;
			
			l = segment.length ;
			
			for( k=0 ; k<l ; k++ ) {
				if( this._testMatch( segment[k], this.source ) ) {
					result.push( segment[k] ) ;
				}
		    }
			if ( result.length != 0 ) {
				return result  ;
			}
			return false ;
        }
		
		return this._testMatch( str, this.source ) ;
		
    }

	
	proto.toString = function () /*String*/ {
		return this.source ;
	}

	// -----o Private Properties
	
	proto._caseSensitive /*Boolean*/ = null ;
	proto._multiline /*Boolean*/ = false ;
	proto._multiword /*Boolean*/ = false ;
	proto._wildcardFound /*Boolean*/ = false ;
	proto._questionMarksFound /*Boolean*/ = false ;

	// ----o Private Methods

	proto._testMatch = function ( str /*String*/ , pattern/*String*/, ignoreChar /*Char*/) /*Boolean*/ {
		
		//str = new String(str) ; // optimization
		//pattern = new String(pattern) ; // optimization
		
		var c, c1, pat, pat1 /*String*/ ;
		
		c = str.charAt( 0 ) ;
		c1 = str.charAt( 1 ) ;
		pat = pattern.charAt( 0 ) ;
		pat1 = pattern.charAt( 1 ) ;
		
		if( pat != "?" ) {
			this._questionMarksFound = false ;
		}
		
        if( pat == "!" ) {
			return this._testMatch( str, pattern.substr( 1 ), pat1 );
		}
        
		if( pat == "?" && ignoreChar != "?" ) {
			if( c != "" ) {
				if( this._questionMarksFound )
				{
					this.addToQuestionMarks( c ) ;
				}
                else 
				{
					this.questionMarks.push( c ) ;
				}
				
				this._questionMarksFound = true ;
				
				if ((pat1 == "") && (this._wildcardFound == true)) {
					pattern += "*" ;
				}
				
                return this._testMatch( str.substr( 1 ), pattern.substr( 1 ) ) ;
				
            } else {
				
				return false ;
				
            }
        }
		
		if( pat == "*" && (ignoreChar != "*") ) {
			
			this._wildcardFound = true ;
			
			if( pat1 != "*" ) {
				this.wildcards.push( "" );
			}
            
			if( pat1 == "" ) {
				this.addToWildcards( str ) ;
				return true ;
            }
			
			if( pattern.substr(1).indexOf( "*" ) > -1 ) {
				
				while( str != "" ) {
					if( pat1 == "*" ) {
						break ;
					}
					if( pat1 == "?" ) {
						pattern = pattern.substr(1) ;
						break ;
					}
					if( str == "" ) {
						return false ;
					}
					if( str.charAt(0) == pat1 ) {
						break ;
					}
					if( pat1 == "!" ) {
						ignoreChar = pattern.charAt( 2 ) ;
						pattern = pattern.substr( 2 ) ;
						pat1 = pattern.charAt( 1 ) ;
					}
					if( str.charAt(0) == ignoreChar ) {
						str = str.substr(1) ; 
						continue ;
					}
					this.addToWildcards( str.charAt( 0 ) ) ;
					str = str.substr(1) ;
				}
				
				return this._testMatch( str, pattern.substr( 1 ), ignoreChar ) ;
				
			} else {
				
				var found /*Number*/ = str.lastIndexOf( pat1 ) ;
				
				if( found != -1 ) {
					
					this.addToWildcards( str.substring( 0, found ) ) ;
					return this._testMatch( str.substr( found ), pattern.substr( 1 ) ) ;
					
                } else if( pat1 == "?" ) {
					
					if( pattern.charAt(2) == "" ) {
						return str.length >= 1 ;
					} else {
						return this._testMatch( str.substr( 1 ), pattern.substr( 1 ) );
					}
					
                }
				return false;
            }
        }
		
		if( pat == "" ) {
			return( c == "" ) ;
		}
		
        if( c != pat ) {
			return false ;
		}
		
        if( c != "" ) {
			return this._testMatch( str.substr( 1 ), pattern.substr( 1 ) ) ;
		} else {
			return false ;
		}
        
    }

	// ----o Encapsulate

	delete constructor ;
	delete proto ;

	// trace ("***** running vegas.string.WildExp") ;

}