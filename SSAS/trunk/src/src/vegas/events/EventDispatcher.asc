/*

  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at 
  
           http://www.mozilla.org/MPL/ 
  
  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the License. 
  
  The Original Code is Vegas Framework.
  
  The Initial Developer of the Original Code is
  ALCARAZ Marc (aka eKameleon)  <vegas@ekameleon.net>.
  Portions created by the Initial Developer are Copyright (C) 2004-2005
  the Initial Developer. All Rights Reserved.
  
  Contributor(s) :
  
*/

/** EventDispatcher

	AUTHOR
		Name : EventDispatcher
		type : SSAS
		Package : vegas.events
		Version : 1.0.0.0
		Author : ekameleon
		Date : 2006-05-27
		URL : http://www.ekameleon.net
		Mail : vegas@ekameleon.net
	
	METHOD SUMMARY
	
	CONSTRUCTOR
	
		new EventDispatcher(target:IEventDispatcher) ;

	USE
	
		load("src/vegas.asc") ;
		
		BasicEvent = vegas.events.BasicEvent ;
		Delegate = vegas.events.Delegate ;
		EventDispatcher = vegas.events.EventDispatcher ;
		
		var EVENT_TYPE = "onTest" ;
		
		var action = function ( e ) {
		
			if( e != undefined) {
				trace ("> action : " + e.getType()) ;
			} else {
				trace ("> action : no event") ;
			}
			
		}
		
		var EVENT_TYPE = "onEVENT" ;
		
		var listener = new Delegate(this, action) ;
		
		var dispatcher = new EventDispatcher() ;
		dispatcher.addEventListener( EVENT_TYPE , listener ) ;
		
		var e = new BasicEvent( EVENT_TYPE , this ) ;
		dispatcher.dispatchEvent(e) ;
	
	PROPERTY SUMMARY
	
		- parent:EventDispatcher

	METHOD SUMMARY
	
		- addChild(child:EventDispatcher):Void
		
		- addEventListener(eventName:String, listener:EventListener, useCapture:Boolean, priority:Number, autoRemove:Boolean)
		
			PARAMS
			
				- eventName:String
					
					String : corresponding of the event type's name
				
					PS : if eventName value is "ALL" addEventListener use addGlobalListener
				
				- listener:EventListener
					
					EventListener object
				
				- useCapture:Boolean
				
				- priority:Number
				
					Determines the priority level of the event listener.
					
				- autoRemove:Boolean
				
					Apply a removeEventListener after the first trigger		
		
		- addGlobalEventListener(listener:EventListener, priority:Number, autoRemove:Boolean)
		
			DESCRIPTION 
			
				apply a global broadcast 
		

		- dispatchEvent( event , [isQueue], [target], [context])
			
			DESCRIPTION
				
				dispatch event
			
			PARAMS
				
				- event : 
				
					- a string 
					- a Event Object
					- a basic object with properties
						- type [obligatory]
						- target [optional]
						- context [optional]
				
				- isQueue [Boolean] [optional]
				
				- target [optional]
				
				- context [optional]
			
			RETURNS 
			
				an Event object or null

		- static flush():Void 
		
			remove all singleton instances
		
		- getEventListeners(eventName:String) : EventListenerCollection
		
			return an EventListenerCollection object for a specific type of event.

		- getGlobalEventListeners()
		
			return a EventListenerCollection object for global events listeners.

		- static getInstance(name:String):EventDispatcher

		- getRegisteredEventNames()
			
			return a HashSet object
	
		- hasEventListener(eventName:String)
		
			Checks whether the EventDispatcher object has any listeners registered for a specific type of event.
			This allows you to determine where altered handling of an event type has been introduced in the event flow heirarchy by an EventDispatcher object.
			To determine whether a specific event type will actually trigger an event listener, use EventDispatcher.willTrigger(). 
		
		- static release(name:String):EventDispatcher
		
		- removeChild(child:EventDispatcher):Void
		
		- removeEventListener(eventName:String, listener )
		
			Removes a listener from the EventDispatcher object.
			If there is no matching listener registered with the EventDispatcher object, then calling this method has no effect. 
		
			Parameters :
			
				- eventName :String -> Specifies the type of event.
				
				- listener -> the class name(string) or a EventListener object.
				
		
		- removeGlobalEventListener( listener ) 

			Removes all "Global" listeners from the EventDispatcher object.

		- static removeInstance(name:String):Boolean
		
		- toString():String

	INHERIT
	
		CoreObject > EventDispatcher

	IMPLEMENTS 
	
		EventTarget, IEventDispatcher, IFormattable, IHashable

	THANKS
	
		EventDispatcher is a AS2 port of the Java.schst.net EventDispatcher. Inspired by the NotificationCenter of Apple's Cocoa-Framework.
		
			- EventDispatcher JAVA : Stephan Schmid - http://schst.net/
			- Cocoa-Framework : http://developer.apple.com/cocoa/
			- Notification center : http://developer.apple.com/documentation/Cocoa/Conceptual/Notifications/index.html

	INHERIT

	IMPLEMENTS
	
		EventTarget â†’ IEventDispatcher	
	
**/ 

if (vegas.events.EventDispatcher == undefined) {

	// ----o Import
	
	loadFile("vegas/data/map/HashMap.asc") ;
	loadFile("vegas/data/set/HashSet.asc") ;
	
	loadFile("vegas/events/EventListenerCollection.asc") ;
	loadFile("vegas/events/EventPhase.asc") ;
	loadFile("vegas/events/EventQueue.asc") ;
	loadFile("vegas/events/IEventDispatcher.asc") ;
	
	loadFile("vegas/util/factory/EventFactory.asc") ;
	loadFile("vegas/util/TypeUtil.asc") ;
	
	// ----o Constructor

	vegas.events.EventDispatcher = function ( target /*IEventDispatcher*/ , parent /*EventDispatcher*/ ) { 
		this._globalListeners = new vegas.events.EventListenerCollection() ;
		this._captures = new vegas.data.map.HashMap() ;
		this._listeners = new vegas.data.map.HashMap() ;
		this._queue = new vegas.events.EventQueue() ;
		this._target = target || this ;
		this.parent = parent || null ;
	}

	var constructor = vegas.events.EventDispatcher ;
	var proto = constructor.extend(vegas.events.IEventDispatcher) ;
	
	// ----o Public Properties
	
	proto.parent = null ; /*EventDispatcher*/
	
	// ----o Private Properties
	
	vegas.events.EventDispatcher.instances /*HashMap*/ = new vegas.data.map.HashMap() ;
	
	proto._globalListeners /*EventListenerCollection*/ = null ;
	proto._captures /*HashMap*/ = null ;
	proto._listeners /*HashMap*/ = null ;
	proto._queue /*EventQueue*/ = null ;
	proto._target /*IEventDispatcher*/ = null ;
	
	// ----o Public Methods
	
	proto.addChild = function ( child /*EventDispatcher*/ ) {
		child.parent = this ;
	}

		
	proto.addEventListener = function ( eventName/*String*/, listener/*EventListener*/, useCapture/*Boolean*/, priority/*Number*/, autoRemove/*Boolean*/) /*Void*/ {
		
		priority = isNaN(priority) ? 0 : priority ;
		
		if (eventName == "ALL") {
			
			this.addGlobalEventListener(listener, priority, autoRemove) ;
			
		} else {
			
			var map /*HashMap*/ = (!useCapture) ? this._listeners : this._captures ;
			
			if (!map.containsKey(eventName)) {
				map.put( eventName, new vegas.events.EventListenerCollection() ) ;
			}
			
			var col /*EventListenerCollection*/ = map.get(eventName) ;
			col.addListener(listener, autoRemove, priority) ;	
			
			this._dispatchQueuedEvents() ;
			
		}
		
	}

	proto.addGlobalEventListener = function(listener/*EventListener*/, priority/*Number*/, autoRemove/*Boolean*/) /*Void*/ {
		this._globalListeners.addListener(listener, autoRemove, priority ) ;
        this._dispatchQueuedEvents() ;
	}

	proto.dispatchEvent = function (event, isQueue/*Boolean*/, target, context) /*Event*/ {
		
		if (!event) return null ;
		
		var e /*Event*/ = vegas.util.factory.EventFactory.create(event, (target || this), context) ;
		
		if ( e == null) return null ;
		
		var phase /*Number*/ = e.getEventPhase() ;
		
		var EventPhase = vegas.events.EventPhase ;
		
		if (phase == EventPhase.AT_TARGET) {
		
			this._capture(e) ; // CAPTURING_PHASE
			
			e.setEventPhase( EventPhase.AT_TARGET ) ;
			
			e.setCurrentTarget(this) ;
			
			this._propagate(e, isQueue || false ) ; // AT_TARGET
			
			this._bubble(e) ; // BUBBLING_PHASE
			
			e.setEventPhase( EventPhase.AT_TARGET ) ; // TODO inclure cette initialisation dans initEvent ??
			
		}
		
		else if (phase == EventPhase.BUBBLING_PHASE) {
			this._propagateBubble(e) ;
		}
		
		else if (phase == EventPhase.CAPTURING_PHASE) {
			
			this._propagateCapture(e) ;
			
		}
		return e ;
		
	}
	
	vegas.events.EventDispatcher.flush = function () /*Void*/ {
	
		vegas.events.EventDispatcher.instances.clear() ;
		
	}

	proto.getEventListeners = function(eventName/*String*/)/*EventListenerCollection*/ {
		
		if ( this._listeners.containsKey(eventName) ) return this._listeners.get(eventName) ;
		
		return new vegas.events.EventListenerCollection() ;
		
	}
	
	proto.getGlobalEventListeners = function()/*EventListenerCollection*/ {
		
		return this._globalListeners ;
		
	}

	vegas.events.EventDispatcher.getInstance = function ( name /*String*/ ) /*EventDispatcher*/ {
		var EventDispatcher = vegas.events.EventDispatcher ;
		if (!name) name = "__default__" ;
		if (! EventDispatcher.instances.containsKey(name) ) {
			EventDispatcher.instances.put(name, new EventDispatcher()) ;
		}
		return EventDispatcher.instances.get(name) ;
	}

	proto.getRegisteredEventNames = function () /*Set*/ {
    	return new vegas.data.set.HashSet( this._listeners.getKeys() ) ;
    }

	proto.getTarget = function () {
		return this._target ;	
	}

	proto.hasEventListener = function(eventName/*String*/)/*Boolean*/ {
		return this._listeners.containsKey(eventName) ;
	}

	vegas.events.EventDispatcher.release = function (name /*String*/ ) /*EventDispatcher*/ {
		if (!name) name = "__default__" ;
		return vegas.events.EventDispatcher.instances.remove(name) ;
	}

	proto.removeChild = function ( child /*EventDispatcher*/ ) /*Void*/ {
		child.parent = null ;
	}

	proto.removeEventListener = function (eventName/*String*/, listener, useCapture/*Boolean*/)/*EventListener*/ {
		
		if (eventName == "ALL") return this.removeGlobalEventListener(listener) ;
		
		if (listener instanceof vegas.events.EventListener || vegas.util.TypeUtil.typesMatch(listener, String))  {
		
			var map /*HashMap*/ = (!useCapture) ? this._listeners : this._captures ;
			
			if (! map.containsKey(eventName) ) return null ;
			
			var col /*EventListenerCollection*/ = map.get(eventName) ;
			
			var container /*EventListenerContainer*/ = col.removeListener(listener) ;
			
			if (container != null) {
			
				return container.getListener() ;
				
			}
			
		}
		
        return null ;
		
	}

	proto.removeGlobalEventListener = function( listener )/*EventListener*/ {
		
		if (listener instanceof EventListener || typeof(listener) == "string") {
			
			var container /*EventListenerContainer*/ = this._globalListeners.removeListener(listener) ;
			
			if (container != null) return container.getListener() ;
			
		}
		
		return null ;
		
	}

	vegas.events.EventDispatcher.removeInstance = function (name /*String*/ ) /*Boolean*/ {
		if (! vegas.events.EventDispatcher.instances.containsKey(name) ) {
			return vegas.events.EventDispatcher.instances.remove(name) != null ;
		} else {
			return false ;
		}
	}
	
	// ----o Private Properties
	
	proto._globalListeners = null ;

	// ----o Private Methods


	proto._bubble = function (e /*Event*/ ) /*Boolean*/ {
	
		var EventPhase = vegas.events.EventPhase ;
		
		
		if (e["stop"] >= EventPhase.STOP ) {
			
			return false ;
			
		}
		
		var parents /*Array*/ = this._getParents() ;
		
		if (parents != null) {
			
			var l /*Number*/ = parents.length ;
			
			var i /*Number*/ = 0 ;
			
			var current /*EventDispatcher*/ ;
			
			while (i<l) {
				if (e.getBubbles()) {
					
					current = parents[i] ;
					
					e.setCurrentTarget(current.getTarget()) ;
					
					e.setEventPhase( EventPhase.BUBBLING_PHASE ) ;
					
					current.dispatchEvent(e) ;
					
					if (e["stop"] >= EventPhase.STOP ) {
						return false ;
					}
					
				}
				i++ ;
			}
		}
		return true ;
	}
	
	proto._capture = function( e /*Event*/ ) /*Boolean*/ {
		
		var parents /*Array*/ = this._getParents() ;
		
		if (parents != null) {
			
			var l /*Number*/ = parents.length ;
			
			var current /*EventDispatcher*/ ;
			
			var EventPhase = vegas.events.EventPhase ;
			
			while (--l > -1) {
				
				current = parents[l] ;
				
				e.setCurrentTarget( current.getTarget() ) ;
				
				e.setEventPhase(EventPhase.CAPTURING_PHASE) ;
				
				current.dispatchEvent(e) ;
				
				if (e["stop"] >= EventPhase.STOP ) {
					return false ;
				}
				
			}
		}
		
		return true ;
		
	}
	
	proto._dispatchQueuedEvents = function() /*Void*/ {
		
		var q /*Queue*/ = this._queue.getQueuedEvents();
		
		if (q.size() > 0) {
			
			var ar /*Array*/ = q.toArray() ;
			
			var len /*Number*/ = ar.length ;
			
			for (var i /*Number*/ = 0 ; i<len ; i++) {
				
				var e /*Event*/ = ar[i] ;
				
				this.dispatchEvent(e, e.isQueued()) ;
				
			}
			
		}
		
	}

	proto._getParents = function () /*Array*/ {
		
		if (this.parent == null) return null ;
		
		var ar /*Array*/ = [] ;
		
		var tmp /*EventDispatcher*/ = this.parent ;
		
		while(tmp != null) {
			
			ar.push(tmp) ;
			tmp = tmp.parent ;
			
		}
		
		return ar ;
		
	}

	proto._propagateBubble = function ( e /*Event*/) /*Void*/ {
		
		var EventPhase = vegas.events.EventPhase ;
		
		if ( e.getEventPhase(EventPhase.BUBBLING_PHASE) ) {
			
			e.setCurrentTarget( this.getTarget() ) ;
			this._propagate(e) ;
			
		}
		
	}
	
	proto._propagateCapture = function ( e /*Event*/ ) /*Void*/ {
		
		var EventPhase = vegas.events.EventPhase ;
		
		if ( this._captures.containsKey( e.getType() ) ) {
			
			e.getEventPhase(EventPhase.CAPTURING_PHASE) ;
            
            var col/*EventListenerCollection*/ = this._captures.get( e.getType() ) ;
            
            col.propagate(e) ;
            
        }
        
	}
	
	proto._propagate = function ( e /*Event*/, isQueue /*Boolean*/ ) /*Event*/ {
	
		var EventPhase = vegas.events.EventPhase ;
		
		if (e["stop"] >= EventPhase.STOP ) {
			
			return e ; // hack the interface limitation
			
		}
		
		if ( this._listeners.containsKey(e.getType()) ) {
            
            var col /*EventListenerCollection*/ = this._listeners.get(e.getType()) ;
            col.propagate(e) ;
            
        }
        
        if ( e.isCancelled() ) {
			
			return e ;
			
		}
        
        this._globalListeners.propagate(e) ;
        
        if (isQueue == false || e.isCancelled()) {
			return e ;
		}
		
        this._queue.enqueue(e) ;
        
        return e ;
        
	}
	
	// ----o Encapsulate

	delete constructor ;
	delete proto ;
	
	//trace ("***** running vegas.events.EventDispatcher") ;
	
}