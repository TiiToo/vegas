/*

  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at 
  
           http://www.mozilla.org/MPL/ 
  
  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the License. 
  
  The Original Code is Vegas Framework.
  
  The Initial Developer of the Original Code is
  ALCARAZ Marc (aka eKameleon)  <vegas@ekameleon.net>.
  Portions created by the Initial Developer are Copyright (C) 2004-2005
  the Initial Developer. All Rights Reserved.
  
  Contributor(s) :
  
*/

/** Class CircularQueue

	AUTHOR

		Name : CircularQueue
		type : SSAS
		Package : vegas.data.queue
		Version : 1.0.0.0
		Author : ekameleon
		Date : 2006-01-12
		URL : http://www.ekameleon.net
		Mail : vegas@ekameleon.net
	
	DESCRIPTION
	
		Abstract data type (ADT) http://en.wikipedia.org/wiki/Abstract_data_type
			Concept de programmation objet.
			Type de données d'un objet uniquement manipulables via les
			fonctions définies dans l'objet lui-même.

		a circular bounded queue
	
	CONSTRUCTOR
	
		new vegas.data.queue.CircularQueue( qSize:Number, ar:Array ) ;

	METHODS
	
		- clear()
		
		- clone()
		
		- dequeue() 
		
			retreive the first element in the queue object, return a boolean.
		
		- element()
		
		- enqueue(o)
		
			enqueue a new element in the queue if the que is not full, return a boolean
		
		- isEmpty()
		
		- isFull()
		
		- iterator()
		
			return a ProtectedIterator
		
		- maxSize():Number
		
		- peek()
		
		- poll()
		
		- size()
		
		- toArray()
		
		- toSource()
		
		- toString()
		
	INHERIT
	
		Object > AbstractCollection > CircularQueue

	IMPLEMENTS
	
		BoundedQueue, Cloneable, Collection, Iterable, Queue, Serializable, ToString
	
	EXAMPLE
	
		var q = new vegas.data.queue.CircularQueue(5) ;
		trace ("maxSize : " + q.maxSize()) ;
		trace ("enqueue item1 : " + q.enqueue ("item1")) ;
		trace ("enqueue item2 : " + q.enqueue ("item2")) ;
		trace ("enqueue item3 : " + q.enqueue ("item3")) ;
		trace ("enqueue item4 : " + q.enqueue ("item4")) ;
		trace ("enqueue item5 : " + q.enqueue ("item5")) ;
		trace ("enqueue item6 : " + q.enqueue ("item6")) ;
		trace ("element : " + q.element()) ;
		trace ("dequeue : " + q.dequeue()) ;
		trace ("element : " + q.element()) ;
		trace ("size : " + q.size()) ;
		trace ("isFull : " + q.isFull()) ; 
		trace ("array : " + q.toArray()) ;
		trace ("q : " + q) ;
		trace ("dequeue : " + q.dequeue()) ;
		trace ("enqueue item6 : " + q.enqueue("item6")) ;
		trace ("enqueue item7 : " + q.enqueue("item7")) ;
		trace ("peek : " + q.peek()) ;
		trace ("size : " + q.size()) ;
		trace ("isFull : " + q.isFull()) ; 
		trace ("q : " + q) ;
		trace ("------- clone") ;
		var clone = q.clone() ;
		trace ("dequeue clone : " + clone.dequeue()) ;
		trace ("enqueue clone item8 : " + clone.enqueue("item8")) ;
		trace ("original queue : " + q) ;
		trace ("clone queue : " + clone) ;
		trace ("clone iterator :") ;
		var i = clone.iterator() ;
		while (i.hasNext()) trace ("\t+ " + i.next()) ;
		trace("clone.toSource : " + clone.toSource()) ;
	
**/ 

_global.getPackage("vegas.data.queue") ;

if (vegas.data.queue.CircularQueue == undefined) {
	
	// ----o Imports
	
	loadFile("vegas/data/iterator/ArrayIterator.asc") ;
	loadFile("vegas/data/collections/AbstractCollection.asc") ;
	loadFile("vegas/data/iterator/ProtectedIterator.asc") ;
	loadFile("vegas/data/queue/QueueFormat.asc") ;
	
	// ----o Constructor

	vegas.data.queue.CircularQueue = function ( qSize /*Number*/ , ar/*Array*/ ) { 
		this._queue = [] ;
		this._qSize = (qSize || CircularQueue.DEFAULT_SIZE) + 1 ;
		this.clear() ;
		if (ar != null && ar.length > 0) {
			var l = ar.length ;
			if (l > 0) for (var i = 0 ; i<l ; i++) this.enqueue(ar[i]) ;
		}
	}

	var constructor = vegas.data.queue.CircularQueue ;
	var proto = constructor.extend(Object) ;

	// ----o Static Property
	
	constructor.DEFAULT_SIZE = Number.MAX_VALUE ;
	
	// ----o Public Methods

	proto.clear = function () {
		this._queue = new Array(this._qSize) ;
		this._count = 0 ;
		this._rear = 0 ;
		this._front = 0 ;
	}

	proto.clone = function () {
		var s /*Number*/ = this._qSize - 1 ;
		var a /*Array*/ = this.toArray() ;
		return new vegas.data.queue.CircularQueue(s , a) ;
	}
	
	proto.contains = function (o) /*Boolean*/ {
		return this._queue.contains(o) ;
	}
	
	proto.dequeue = function () /*Boolean*/ {
		return this.poll() != null  ;
	}
	
	proto.element = function () {
		return this._queue[this._front] ;
	}

	proto.enqueue = function (o) /*Boolean*/ {
		var next /*Number*/ = this._rear + 1 ;
		if ( (next == this._front) || ( ( next == this._qSize) && (this._front == 0) )) {
			return false ;
		} else {
			this._queue[this._rear++] = o ;
			this._count ++ ;
			if (this._rear == this._qSize) this._rear = 0 ;
		}
		return true ;
	}

	proto.get = function (id/*Number*/) { // Collection implementation
		throw new vegas.errors.UnsupportedOperationError("CircularQueue 'get' method is unsupported.") ;
	}

	proto.insert = function (o) /*Boolean*/ { // Collection implementation
		throw new vegas.errors.UnsupportedOperationError("CircularQueue 'insert' method is unsupported.") ;
	}

	proto.isEmpty = function () /*Boolean*/ {
		return this._count == 0 ;
	}

	proto.isFull = function () /*Boolean*/ {
		return this._count == this.maxSize() ;
	}
	
	proto.iterator = function ()  /*Iterator*/ {
		var it = new vegas.data.iterator.ArrayIterator(this.toArray()) ;
		return new vegas.data.iterator.ProtectedIterator(it) ;
	}

	proto.maxSize = function () /*Number*/ {
		return this._qSize -1 ;
	}
	
	proto.peek = function () {
		return this.isEmpty() ? null : this._queue[this._front] ;
	}
	
	proto.poll = function () {
		if (this._front == this._qSize) this._front = 0 ; // loop back
        if (this._front == this._rear) return null;  // queue is empty
        else  {
            this._count-- ;
            var mem = this._queue[this._front] ;
            this._queue[this._front] = undefined ;
            this._front++ ;
            return mem ; // return mem object
        }
	}	
	
	proto.remove = function (o) /*Boolean*/ {
		throw new vegas.errors.UnsupportedOperationError("CircularQueue 'remove' method is unsupported.") ;
	}
	
	proto.size = function () /*Number*/ {
		return this._count ;
	}
	
	proto.toArray = function () /*Array*/ {
		if (this._count == 0) {
			return new Array ;
		} else {
			var r /*Array*/ = new Array(this._count) ;
			var i /*Number*/ = (this._front == this._qSize) ? 0 : this._front ;
			var cpt /*Number*/ = 0 ;
			while (cpt < this._count) {
				r[cpt++] = this._queue[i++] ;
				if (i == this._qSize) i = 0 ;
			}
			return r ;
		}
	}

	proto.toSource = function (indent /*Number*/, indentor/*String*/ ) /*String*/ {
		var sourceA /*String*/ = this.maxSize().toSource() ;
		var sourceB /*String*/ = (this.toArray()).toSource() ;
		return "new vegas.data.queue.CircularQueue(" + sourceA + "," + sourceB + ")" ;
	}

	proto.toString = function () /*String*/ {
		return (new vegas.data.queue.QueueFormat()).formatToString(this) ;
	}
	
	// ----o Encapsulate

	delete constructor ;
	delete proto ;
	
	//trace ("***** running vegas.data.queue.CircularQueue") ;
	
}