<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><script src="../../quicknav.js" type="text/javascript"></script><script><!--
document.quicknavBasePath="../../index-files";
//--></script><link href="../../style.css" title="JavaDoc" rel="stylesheet" type="text/css"/><link href="../../unnatural.css" title="Unnatural" rel="alternate stylesheet" type="text/css"/><link href="../../overview-summary.html" title="Overview" rel="top"/><meta name="generator" content="http://www.badgers-in-foil.co.uk/projects/as2api/"/></head><body><pre><span class="lineno" id="1">     1  </span><span class="comment">/*
<span class="lineno" id="2">     2  </span>
<span class="lineno" id="3">     3  </span>  The contents of this file are subject to the Mozilla Public License Version
<span class="lineno" id="4">     4  </span>  1.1 (the "License"); you may not use this file except in compliance with
<span class="lineno" id="5">     5  </span>  the License. You may obtain a copy of the License at 
<span class="lineno" id="6">     6  </span>  
<span class="lineno" id="7">     7  </span>           http://www.mozilla.org/MPL/ 
<span class="lineno" id="8">     8  </span>  
<span class="lineno" id="9">     9  </span>  Software distributed under the License is distributed on an "AS IS" basis,
<span class="lineno" id="10">    10  </span>  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
<span class="lineno" id="11">    11  </span>  for the specific language governing rights and limitations under the License. 
<span class="lineno" id="12">    12  </span>  
<span class="lineno" id="13">    13  </span>  The Original Code is Vegas Framework.
<span class="lineno" id="14">    14  </span>  
<span class="lineno" id="15">    15  </span>  The Initial Developer of the Original Code is
<span class="lineno" id="16">    16  </span>  ALCARAZ Marc (aka eKameleon)  &lt;vegas@ekameleon.net&gt;.
<span class="lineno" id="17">    17  </span>  Portions created by the Initial Developer are Copyright (C) 2004-2008
<span class="lineno" id="18">    18  </span>  the Initial Developer. All Rights Reserved.
<span class="lineno" id="19">    19  </span>  
<span class="lineno" id="20">    20  </span>  Contributor(s) :
<span class="lineno" id="21">    21  </span>  
<span class="lineno" id="22">    22  </span>*/</span>
<span class="lineno" id="23">    23  </span>
<span class="lineno" id="24">    24  </span><span class="key">import</span> vegas.errors.ArgumentOutOfBoundsError;
<span class="lineno" id="25">    25  </span><span class="key">import</span> vegas.util.Copier;
<span class="lineno" id="26">    26  </span>
<span class="lineno" id="27">    27  </span><span class="comment doc">/**
<span class="lineno" id="28">    28  </span> * The {@code ArrayUtil} utility class is an all-static class with methods for working with array.
<span class="lineno" id="29">    29  </span> * &lt;p&gt;You do not create instances of {@code ArrayUtil}, instead you call static methods.&lt;/p&gt;
<span class="lineno" id="30">    30  </span> * @author eKameleon
<span class="lineno" id="31">    31  </span> */</span>
<span class="lineno" id="32">    32  </span><span class="key">class</span> vegas.util.ArrayUtil 
<span class="lineno" id="33">    33  </span>{
<span class="lineno" id="34">    34  </span>
<span class="lineno" id="35">    35  </span>    <span class="comment doc">/**
<span class="lineno" id="36">    36  </span>     * Creates a shallow copy of the Array.
<span class="lineno" id="37">    37  </span>     * @return a shallow copy of the Array.
<span class="lineno" id="38">    38  </span>     */</span>
<span class="lineno" id="39">    39  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> clone(ar:Array):Array 
<span class="lineno" id="40">    40  </span>	{
<span class="lineno" id="41">    41  </span>		<span class="key">return</span> ar.slice() ;
<span class="lineno" id="42">    42  </span>	}
<span class="lineno" id="43">    43  </span>
<span class="lineno" id="44">    44  </span>    <span class="comment doc">/**
<span class="lineno" id="45">    45  </span>     * Returns whether the Array contains a particular item.
<span class="lineno" id="46">    46  </span>     * @param ar the Array to check.
<span class="lineno" id="47">    47  </span>     * @param value the value to find in the array.
<span class="lineno" id="48">    48  </span>     */</span>
<span class="lineno" id="49">    49  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> contains( ar:Array , value:Object):Boolean 
<span class="lineno" id="50">    50  </span>	{
<span class="lineno" id="51">    51  </span>		<span class="key">return</span> (indexOf(ar, value) &gt; -<span class="num_const">1</span>) ;
<span class="lineno" id="52">    52  </span>	}
<span class="lineno" id="53">    53  </span>
<span class="lineno" id="54">    54  </span>    <span class="comment doc">/**
<span class="lineno" id="55">    55  </span>     * Returns and creates a deep copy of the Array.
<span class="lineno" id="56">    56  </span>     * @param ar the Array to copy.
<span class="lineno" id="57">    57  </span>     * @return a deep copy of the specified Array passed in argument.
<span class="lineno" id="58">    58  </span>   	 */</span>
<span class="lineno" id="59">    59  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> copy(ar:Array):Array 
<span class="lineno" id="60">    60  </span>	{
<span class="lineno" id="61">    61  </span>		<span class="key">var</span> a:Array = [] ;
<span class="lineno" id="62">    62  </span>		<span class="key">var</span> i:Number ;
<span class="lineno" id="63">    63  </span>		<span class="key">var</span> l:Number = ar.length ;
<span class="lineno" id="64">    64  </span>		<span class="key">for</span> (i = <span class="num_const">0</span> ; i &lt; l ; i++) 
<span class="lineno" id="65">    65  </span>		{
<span class="lineno" id="66">    66  </span>			<span class="key">if</span>( ar[i] === undefined ) 
<span class="lineno" id="67">    67  </span>			{
<span class="lineno" id="68">    68  </span>				a[i] = undefined ;
<span class="lineno" id="69">    69  </span>			}
<span class="lineno" id="70">    70  </span>			<span class="key">else</span> <span class="key">if</span>( ar[i] === <span class="key">null</span> ) 
<span class="lineno" id="71">    71  </span>			{
<span class="lineno" id="72">    72  </span>				a[i] = <span class="key">null</span> ;
<span class="lineno" id="73">    73  </span>            } 
<span class="lineno" id="74">    74  </span>            <span class="key">else</span> 
<span class="lineno" id="75">    75  </span>            {
<span class="lineno" id="76">    76  </span>				a[i] = Copier.copy(ar[i]) ;
<span class="lineno" id="77">    77  </span>			}
<span class="lineno" id="78">    78  </span>		}
<span class="lineno" id="79">    79  </span>		<span class="key">return</span> a ;
<span class="lineno" id="80">    80  </span>	}
<span class="lineno" id="81">    81  </span>
<span class="lineno" id="82">    82  </span>	<span class="comment doc">/**
<span class="lineno" id="83">    83  </span>	 * Returns {@code true} if every element in this array satisfies the provided testing function.
<span class="lineno" id="84">    84  </span>	 * &lt;p&gt;{@code every} executes the provided {@code callback} function once for each element present in the array until it finds one where callback returns a false value. If such an element is found, the every method immediately returns {@code false}.&lt;/p&gt;
<span class="lineno" id="85">    85  </span>	 * &lt;p&gt;Otherwise, if {@code callback} returned a {@code true} value for all elements, every will return {@code true}.&lt;/p&gt;
<span class="lineno" id="86">    86  </span>	 * &lt;p&gt;{@code callback} is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values.&lt;/p&gt;
<span class="lineno" id="87">    87  </span>	 * &lt;p&gt;{@code callback} is invoked with three arguments: the value of the element, the index of the element, and the Array object being traversed.&lt;/p&gt;
<span class="lineno" id="88">    88  </span>	 * &lt;p&gt;&lt;b&gt;Example :&lt;/b&gt;&lt;/p&gt;
<span class="lineno" id="89">    89  </span>	 * {@code
<span class="lineno" id="90">    90  </span>	 * import vegas.util.ArrayUtil ;
<span class="lineno" id="91">    91  </span>	 * 
<span class="lineno" id="92">    92  </span>	 * function isBigEnough(element, index, array) 
<span class="lineno" id="93">    93  </span>	 * {
<span class="lineno" id="94">    94  </span>	 *     return (element &gt;= 10);
<span class="lineno" id="95">    95  </span>	 * }
<span class="lineno" id="96">    96  </span>	 * var passed ;
<span class="lineno" id="97">    97  </span>	 * passed = ArrayUtil.every([12, 5, 8, 130, 44], isBigEnough) ; // passed is false
<span class="lineno" id="98">    98  </span>	 * passed = ArrayUtil.every([12, 54, 18, 130, 44], isBigEnough); // passed is true
<span class="lineno" id="99">    99  </span>	 * 
<span class="lineno" id="100">   100  </span>	 * }
<span class="lineno" id="101">   101  </span>	 * @param ar the array to transform.
<span class="lineno" id="102">   102  </span>	 * @param callback Function to test for each element.
<span class="lineno" id="103">   103  </span>	 * @param o Object to use as this when executing callback.
<span class="lineno" id="104">   104  </span>	 * @return {@code true} if every element in this array satisfies the provided testing function.
<span class="lineno" id="105">   105  </span>	 */</span>
<span class="lineno" id="106">   106  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> every(ar:Array, callback:Function, o:Object ):Boolean 
<span class="lineno" id="107">   107  </span>	{
<span class="lineno" id="108">   108  </span>		<span class="key">if</span>(!o) o = _global ;
<span class="lineno" id="109">   109  </span>		<span class="key">var</span> len:Number = ar.length ;
<span class="lineno" id="110">   110  </span>		<span class="key">for</span> (<span class="key">var</span> i:Number = <span class="num_const">0</span> ; i&lt;len ; i++) 
<span class="lineno" id="111">   111  </span>		{
<span class="lineno" id="112">   112  </span>			<span class="key">if</span>( !callback.call( o, ar[i], i, ar ) ) 
<span class="lineno" id="113">   113  </span>			{
<span class="lineno" id="114">   114  </span>				<span class="key">return</span> <span class="key">false</span> ;
<span class="lineno" id="115">   115  </span>			}
<span class="lineno" id="116">   116  </span>        }
<span class="lineno" id="117">   117  </span>		<span class="key">return</span> <span class="key">true</span> ;
<span class="lineno" id="118">   118  </span>    }
<span class="lineno" id="119">   119  </span>
<span class="lineno" id="120">   120  </span>	<span class="comment doc">/**
<span class="lineno" id="121">   121  </span>	 * Calls a provided callback function once for each element in an array, and constructs a new array of all the values for which callback returns a true value.
<span class="lineno" id="122">   122  </span>	 * &lt;p&gt;{@code callback} is invoked only for indexes of the array which have assigned values;
<span class="lineno" id="123">   123  </span>	 * it is not invoked for indexes which have been deleted or which have never been assigned values.&lt;/p&gt; 
<span class="lineno" id="124">   124  </span>	 * &lt;p&gt;Array elements which do not pass the callback test are simply skipped, and are not included in the new array.&lt;/p&gt;
<span class="lineno" id="125">   125  </span>	 * &lt;p&gt;{@code callback} is invoked with three arguments: the value of the element, the index of the element, and the Array object being traversed.&lt;/p&gt;
<span class="lineno" id="126">   126  </span>	 * &lt;p&gt;If a {@code thisObject} parameter is provided to filter, it will be used as the this for each invocation of the callback. If it is not provided, or is {@code null}, the global object associated with callback is used instead.&lt;/p&gt;
<span class="lineno" id="127">   127  </span>	 * &lt;p&gt;filter does not mutate the array on which it is called.&lt;/p&gt;
<span class="lineno" id="128">   128  </span>	 * &lt;p&gt;The range of elements processed by filter is set before the first invocation of {@code callback}. 
<span class="lineno" id="129">   129  </span>	 * Elements which are appended to the array after the call to filter begins will not be visited by {@code callback}. 
<span class="lineno" id="130">   130  </span>	 * If existing elements of the array are changed, or deleted, their value as passed to callback will be the value at the time filter visits them; elements that are deleted are not visited.&lt;/p&gt;
<span class="lineno" id="131">   131  </span>	 * &lt;p&gt;&lt;b&gt;Example :&lt;/b&gt;&lt;/p&gt;
<span class="lineno" id="132">   132  </span>	 * {@code
<span class="lineno" id="133">   133  </span>	 * import vegas.util.ArrayUtil ;
<span class="lineno" id="134">   134  </span>	 * 
<span class="lineno" id="135">   135  </span>	 * function isBigEnough(element, index, array) 
<span class="lineno" id="136">   136  </span>	 * {
<span class="lineno" id="137">   137  </span>	 *     return (element &gt;= 10) ;
<span class="lineno" id="138">   138  </span>	 * }
<span class="lineno" id="139">   139  </span>	 * var ar:Array = [12, 5, 8, 130, 44] ;
<span class="lineno" id="140">   140  </span>	 * var filtered:Array = ArrayUtil.filter(ar, isBigEnough);
<span class="lineno" id="141">   141  </span>	 * trace(ar + " : " + filtered) ;
<span class="lineno" id="142">   142  </span>	 * }
<span class="lineno" id="143">   143  </span>	 * @param ar the Array to filter.
<span class="lineno" id="144">   144  </span>	 * @param callback Function to test each element of the array.
<span class="lineno" id="145">   145  </span>	 * @param thisObject Object to use as this when executing callback.
<span class="lineno" id="146">   146  </span>	 * @return a new array of all the values for which callback returns a true value.
<span class="lineno" id="147">   147  </span>	 */</span>
<span class="lineno" id="148">   148  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> filter( ar:Array, callback:Function, thisObject ):Array
<span class="lineno" id="149">   149  </span>	{
<span class="lineno" id="150">   150  </span>		<span class="key">var</span> arr:Array = [];
<span class="lineno" id="151">   151  </span>        <span class="key">if</span>( thisObject == <span class="key">null</span> ) 
<span class="lineno" id="152">   152  </span>        {
<span class="lineno" id="153">   153  </span>        	thisObject = _global ;
<span class="lineno" id="154">   154  </span>        }
<span class="lineno" id="155">   155  </span>		<span class="key">var</span> len:Number = ar.length ;
<span class="lineno" id="156">   156  </span>		<span class="key">for</span>( <span class="key">var</span> i:Number = <span class="num_const">0</span>; i&lt;len ; i++ )
<span class="lineno" id="157">   157  </span>		{
<span class="lineno" id="158">   158  </span>        	<span class="key">if</span>( callback.call( thisObject, ar[i], i, ar ) )
<span class="lineno" id="159">   159  </span>	        {
<span class="lineno" id="160">   160  </span>				<span class="key">if</span>( ar[i] === undefined )
<span class="lineno" id="161">   161  </span>				{
<span class="lineno" id="162">   162  </span>					arr.push( undefined );
<span class="lineno" id="163">   163  </span>					<span class="key">continue</span>;
<span class="lineno" id="164">   164  </span>				}
<span class="lineno" id="165">   165  </span>				<span class="key">if</span>( ar[i] === <span class="key">null</span> )
<span class="lineno" id="166">   166  </span>	            {
<span class="lineno" id="167">   167  </span>                	arr.push( <span class="key">null</span> );
<span class="lineno" id="168">   168  </span>                    <span class="key">continue</span>;
<span class="lineno" id="169">   169  </span>				}
<span class="lineno" id="170">   170  </span>                	arr.push( Copier.copy(ar[i]) );
<span class="lineno" id="171">   171  </span>			}
<span class="lineno" id="172">   172  </span>                	
<span class="lineno" id="173">   173  </span>		}
<span class="lineno" id="174">   174  </span>        <span class="key">return</span> arr;
<span class="lineno" id="175">   175  </span>	}
<span class="lineno" id="176">   176  </span>
<span class="lineno" id="177">   177  </span>	<span class="comment doc">/**
<span class="lineno" id="178">   178  </span>	 * Executes the provided function (callback) once for each element present in the array. callback is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values.
<span class="lineno" id="179">   179  </span>	 * &lt;p&gt;{@code callback} is invoked with three arguments: the value of the element, the index of the element, and the Array object being traversed.&lt;/p&gt;
<span class="lineno" id="180">   180  </span>	 * &lt;p&gt;If a {@code thisObject} parameter is provided to forEach, it will be used as the this for each invocation of the callback. If it is not provided, or is null, the global object associated with callback is used instead.&lt;/p&gt;
<span class="lineno" id="181">   181  </span>	 * &lt;p&gt;forEach does not mutate the array on which it is called.&lt;/p&gt;
<span class="lineno" id="182">   182  </span>	 * &lt;p&gt;The range of elements processed by forEach is set before the first invocation of callback. 
<span class="lineno" id="183">   183  </span>	 * Elements which are appended to the array after the call to forEach begins will not be visited by callback. If existing elements of the array are changed, or deleted, their value as passed to callback will be the value at the time forEach visits them; 
<span class="lineno" id="184">   184  </span>	 * elements that are deleted are not visited.&lt;/p&gt;
<span class="lineno" id="185">   185  </span>	 * &lt;p&gt;&lt;b&gt;Example :&lt;/b&gt;&lt;/p&gt;
<span class="lineno" id="186">   186  </span>	 * {@code
<span class="lineno" id="187">   187  </span>	 * import vegas.util.ArrayUtil ;
<span class="lineno" id="188">   188  </span>	 * 
<span class="lineno" id="189">   189  </span>	 * var stack:Array = [] ;
<span class="lineno" id="190">   190  </span>	 * 
<span class="lineno" id="191">   191  </span>	 * var printElt:Function = function(element, index, array) 
<span class="lineno" id="192">   192  </span>	 * {
<span class="lineno" id="193">   193  </span>	 *     stack.push("[" + index + "] is " + element); // assumes print is already defined
<span class="lineno" id="194">   194  </span>	 * }
<span class="lineno" id="195">   195  </span>	 * 
<span class="lineno" id="196">   196  </span>	 * ArrayUtil.forEach([2, 5, 9], printElt);
<span class="lineno" id="197">   197  </span>	 * 
<span class="lineno" id="198">   198  </span>	 * trace(stack) ;
<span class="lineno" id="199">   199  </span>	 * }
<span class="lineno" id="200">   200  </span>	 * @param ar the array to transform.
<span class="lineno" id="201">   201  </span>	 * @param callback Executes a provided function once per array element.
<span class="lineno" id="202">   202  </span>	 * @param o Object to use as this when executing callback.
<span class="lineno" id="203">   203  </span>	 */</span>
<span class="lineno" id="204">   204  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> forEach(ar:Array, callback:Function, o):Void 
<span class="lineno" id="205">   205  </span>	{
<span class="lineno" id="206">   206  </span>        <span class="key">var</span> len:Number = ar.length ; 
<span class="lineno" id="207">   207  </span>		<span class="key">var</span> i:Number ;
<span class="lineno" id="208">   208  </span>        <span class="key">if</span>( o == <span class="key">null</span> ) o = _global ;
<span class="lineno" id="209">   209  </span>        <span class="key">for</span>( i=<span class="num_const">0</span>; i&lt;len ; i++ ) 
<span class="lineno" id="210">   210  </span>        {
<span class="lineno" id="211">   211  </span>        	callback.call(o, ar[i], i, ar) ;
<span class="lineno" id="212">   212  </span>        }
<span class="lineno" id="213">   213  </span>    }
<span class="lineno" id="214">   214  </span>
<span class="lineno" id="215">   215  </span>	<span class="comment doc">/**
<span class="lineno" id="216">   216  </span>	 * Returns an new array from arguments in a function.
<span class="lineno" id="217">   217  </span>	 * @return an new array from arguments in a function.
<span class="lineno" id="218">   218  </span>	 */</span>
<span class="lineno" id="219">   219  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> fromArguments( ar:Array, args:Array ):Array 
<span class="lineno" id="220">   220  </span>	{
<span class="lineno" id="221">   221  </span>		<span class="key">return</span> ar.concat(args) ;	
<span class="lineno" id="222">   222  </span>    }
<span class="lineno" id="223">   223  </span>    
<span class="lineno" id="224">   224  </span>	<span class="comment doc">/**
<span class="lineno" id="225">   225  </span>	 * Returns the index of the first occurrence of a value in a one-dimensional Array or in a portion of the Array.
<span class="lineno" id="226">   226  </span>	 * @param ar the array reference.
<span class="lineno" id="227">   227  </span>	 * @param value the value to search in the array.
<span class="lineno" id="228">   228  </span>	 * @param startIndex optionnal, allows to specify the starting index of the search.
<span class="lineno" id="229">   229  </span>	 * @param count	allows to limit the number of elements to search in the array.
<span class="lineno" id="230">   230  </span>	 * @return the index of the first occurrence of a value in a one-dimensional Array or in a portion of the Array.
<span class="lineno" id="231">   231  </span>	 */</span>
<span class="lineno" id="232">   232  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> indexOf( ar:Array, value:Object, startIndex:Number, count:Number):Number 
<span class="lineno" id="233">   233  </span>	{
<span class="lineno" id="234">   234  </span>		<span class="key">var</span> l:Number = ar.length ;
<span class="lineno" id="235">   235  </span>		<span class="key">if</span>(isNaN(startIndex) ) startIndex = <span class="num_const">0</span> ;
<span class="lineno" id="236">   236  </span>        <span class="key">if</span>(isNaN(count)) 
<span class="lineno" id="237">   237  </span>        {
<span class="lineno" id="238">   238  </span>        	count = ar.length  - startIndex ;
<span class="lineno" id="239">   239  </span>        }
<span class="lineno" id="240">   240  </span>		<span class="key">if</span> (startIndex &lt; <span class="num_const">0</span> || startIndex &gt; l) 
<span class="lineno" id="241">   241  </span>		{
<span class="lineno" id="242">   242  </span>			<span class="key">throw</span> <span class="key">new</span> ArgumentOutOfBoundsError(<span class="str_const">"ArrayUtil.indexOf : 'startIndex' must be between 0 and "</span> + l + <span class="str_const">"."</span>);
<span class="lineno" id="243">   243  </span>		}
<span class="lineno" id="244">   244  </span>		<span class="key">if</span> (count &lt; <span class="num_const">0</span> || count &gt; (l - startIndex)) 
<span class="lineno" id="245">   245  </span>		{
<span class="lineno" id="246">   246  </span>			<span class="key">throw</span> <span class="key">new</span> ArgumentOutOfBoundsError(<span class="str_const">"ArrayUtil.indexOf : 'count' must be between 'startIndex' and the array size -1."</span>) ;
<span class="lineno" id="247">   247  </span>		}
<span class="lineno" id="248">   248  </span>		<span class="key">for</span> (<span class="key">var</span> i:Number = <span class="num_const">0</span> ; startIndex &lt; l ; startIndex++ , i++) 
<span class="lineno" id="249">   249  </span>		{
<span class="lineno" id="250">   250  </span>			<span class="key">if</span> (ar[startIndex] == value) 
<span class="lineno" id="251">   251  </span>			{
<span class="lineno" id="252">   252  </span>				<span class="key">return</span> startIndex ;
<span class="lineno" id="253">   253  </span>			} 
<span class="lineno" id="254">   254  </span>			<span class="key">if</span> (i == count) 
<span class="lineno" id="255">   255  </span>			{
<span class="lineno" id="256">   256  </span>				<span class="key">break</span> ;
<span class="lineno" id="257">   257  </span>			}
<span class="lineno" id="258">   258  </span>		}
<span class="lineno" id="259">   259  </span>		<span class="key">return</span> -<span class="num_const">1</span> ;
<span class="lineno" id="260">   260  </span>	}
<span class="lineno" id="261">   261  </span>
<span class="lineno" id="262">   262  </span>	<span class="comment doc">/**
<span class="lineno" id="263">   263  </span>	 * Creates and Initializes an Array.
<span class="lineno" id="264">   264  </span>	 * @return a new Array fill by the specified value.
<span class="lineno" id="265">   265  </span>	 */</span>
<span class="lineno" id="266">   266  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> initialize(index:Number, value:Object):Array 
<span class="lineno" id="267">   267  </span>	{
<span class="lineno" id="268">   268  </span>		<span class="key">if</span>( isNaN(index) ) 
<span class="lineno" id="269">   269  </span>		{
<span class="lineno" id="270">   270  </span>			index = <span class="num_const">0</span> ;
<span class="lineno" id="271">   271  </span>		}
<span class="lineno" id="272">   272  </span>		<span class="key">if</span>( value === undefined ) 
<span class="lineno" id="273">   273  </span>		{
<span class="lineno" id="274">   274  </span>			value = <span class="key">null</span> ;
<span class="lineno" id="275">   275  </span>		}
<span class="lineno" id="276">   276  </span>        <span class="key">var</span> ar:Array = [] ;
<span class="lineno" id="277">   277  </span>		<span class="key">for</span>( <span class="key">var</span> i:Number = <span class="num_const">0</span> ; i&lt;index ; i++ ) 
<span class="lineno" id="278">   278  </span>		{
<span class="lineno" id="279">   279  </span>			ar[i] = value ;
<span class="lineno" id="280">   280  </span>		}
<span class="lineno" id="281">   281  </span>		<span class="key">return</span> ar ;
<span class="lineno" id="282">   282  </span>    }
<span class="lineno" id="283">   283  </span>
<span class="lineno" id="284">   284  </span>	<span class="comment doc">/**
<span class="lineno" id="285">   285  </span>	 * Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
<span class="lineno" id="286">   286  </span>	 * &lt;p&gt;&lt;b&gt;Example :&lt;/b&gt;&lt;/p&gt;
<span class="lineno" id="287">   287  </span>	 * {@code
<span class="lineno" id="288">   288  </span>	 * import vegas.util.ArrayUtil ;
<span class="lineno" id="289">   289  </span>	 * var ar:Array = [2, 3, 4, 2, 5] ;
<span class="lineno" id="290">   290  </span>	 * var index:Number = ArrayUtil.lastIndexOf(2) ; 
<span class="lineno" id="291">   291  </span>	 * trace(index) ; // 3
<span class="lineno" id="292">   292  </span>	 * }
<span class="lineno" id="293">   293  </span>	 * @return the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
<span class="lineno" id="294">   294  </span>	 */</span>
<span class="lineno" id="295">   295  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> lastIndexOf( ar:Array, o ) :Number 
<span class="lineno" id="296">   296  </span>	{
<span class="lineno" id="297">   297  </span>		<span class="key">var</span> l:Number = ar.length;
<span class="lineno" id="298">   298  </span>		<span class="key">while</span> ( --l &gt; -<span class="num_const">1</span> ) <span class="key">if</span> (ar[l] == o) <span class="key">return</span> l ; 
<span class="lineno" id="299">   299  </span>		<span class="key">return</span> -<span class="num_const">1</span> ;
<span class="lineno" id="300">   300  </span>	}
<span class="lineno" id="301">   301  </span>
<span class="lineno" id="302">   302  </span>	<span class="comment doc">/**
<span class="lineno" id="303">   303  </span>	 * Creates a new array with the results of calling a provided function on every element in this array.
<span class="lineno" id="304">   304  </span>	 * &lt;p&gt;{@code map} calls a provided callback function once for each element in an array, in order, and constructs a new array from the results. 
<span class="lineno" id="305">   305  </span>	 * {@code callback} is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values.&lt;/p&gt;
<span class="lineno" id="306">   306  </span>	 * &lt;p&gt;{@code callback} is invoked with three arguments: the value of the element, the index of the element, and the Array object being traversed.&lt;/p&gt;
<span class="lineno" id="307">   307  </span>	 * &lt;p&gt;If a {@code thisObject} parameter is provided to map, it will be used as the this for each invocation of the callback. If it is not provided, or is null, the global object associated with callback is used instead.&lt;/p&gt;
<span class="lineno" id="308">   308  </span>	 * &lt;p&gt;{@code map} does not mutate the array on which it is called.&lt;/p&gt;
<span class="lineno" id="309">   309  </span>	 * &lt;p&gt;The range of elements processed by map is set before the first invocation of {@code callback}. 
<span class="lineno" id="310">   310  </span>	 * Elements which are appended to the array after the call to map begins will not be visited by {@code callback}. 
<span class="lineno" id="311">   311  </span>	 * If existing elements of the array are changed, or deleted, their value as passed to callback will be the value at the time map visits them; elements that are deleted are not visited.&lt;/p&gt;
<span class="lineno" id="312">   312  </span>	 * &lt;p&gt;&lt;b&gt;Example :&lt;/b&gt;&lt;/p&gt;
<span class="lineno" id="313">   313  </span>	 * {@code
<span class="lineno" id="314">   314  </span>	 * import vegas.util.ArrayUtil ;
<span class="lineno" id="315">   315  </span>	 * 
<span class="lineno" id="316">   316  </span>	 * var makeUpperCase:Function = function( element )
<span class="lineno" id="317">   317  </span>	 * {
<span class="lineno" id="318">   318  </span>	 *     return element.toUpperCase() ;
<span class="lineno" id="319">   319  </span>	 * }
<span class="lineno" id="320">   320  </span>	 * 
<span class="lineno" id="321">   321  </span>	 * var ar:Array = ["hello", "WorlD", "Yoo"] ;
<span class="lineno" id="322">   322  </span>	 * var uppers = ArrayUtil.map(ar, makeUpperCase) ;
<span class="lineno" id="323">   323  </span>	 * // uppers is now ["HELLO", "WORLD", "YOO"].
<span class="lineno" id="324">   324  </span>	 * // ar is unchanged.
<span class="lineno" id="325">   325  </span>	 * }
<span class="lineno" id="326">   326  </span>	 * @param ar the array to map.
<span class="lineno" id="327">   327  </span>	 * @param callback Function produce an element of the new Array from an element of the current one.
<span class="lineno" id="328">   328  </span>	 * @param thisObject Object to use as this when executing callback.
<span class="lineno" id="329">   329  </span>	 */</span>
<span class="lineno" id="330">   330  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> map( ar:Array, callback:Function, thisObject ):Array 
<span class="lineno" id="331">   331  </span>	{
<span class="lineno" id="332">   332  </span>        
<span class="lineno" id="333">   333  </span>		<span class="key">var</span> arr:Array = [] ;
<span class="lineno" id="334">   334  </span>		<span class="key">var</span> i:Number ;
<span class="lineno" id="335">   335  </span>		<span class="key">if</span>( thisObject == <span class="key">null</span> ) 
<span class="lineno" id="336">   336  </span>		{
<span class="lineno" id="337">   337  </span>			thisObject = <span class="key">null</span> ;
<span class="lineno" id="338">   338  </span>		}
<span class="lineno" id="339">   339  </span>		<span class="key">var</span> l:Number = ar.length ;
<span class="lineno" id="340">   340  </span>        <span class="key">for</span>( i=<span class="num_const">0</span> ; i&lt;l ; i++ ) 
<span class="lineno" id="341">   341  </span>        {
<span class="lineno" id="342">   342  </span>            arr[i] = callback.call( thisObject, ar[i], i, ar ) ;
<span class="lineno" id="343">   343  </span>        }
<span class="lineno" id="344">   344  </span>        
<span class="lineno" id="345">   345  </span>        <span class="key">return</span> arr ;
<span class="lineno" id="346">   346  </span>    
<span class="lineno" id="347">   347  </span>    }
<span class="lineno" id="348">   348  </span>    
<span class="lineno" id="349">   349  </span>	<span class="comment doc">/**
<span class="lineno" id="350">   350  </span>	 * Splices an array (removes an element) and returns either the entire array or the removed element.
<span class="lineno" id="351">   351  </span>	 * &lt;p&gt;{@code
<span class="lineno" id="352">   352  </span>	 * import vegas.util.ArrayUtil ;
<span class="lineno" id="353">   353  </span>	 * var ar = new Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
<span class="lineno" id="354">   354  </span>	 * trace("+ " + ar);
<span class="lineno" id="355">   355  </span>	 * ArrayUtil.pierce( ar, 1 ) ;
<span class="lineno" id="356">   356  </span>	 * trace("+ " + ar) ;
<span class="lineno" id="357">   357  </span>	 * }
<span class="lineno" id="358">   358  </span>	 * &lt;/p&gt;
<span class="lineno" id="359">   359  </span>	 * @param ar the array.
<span class="lineno" id="360">   360  </span>	 * @param index the index of the array element to remove from the array.
<span class="lineno" id="361">   361  </span>	 * @param flag a boolean {@code true} to return a new spliced array of false to return the removed element.
<span class="lineno" id="362">   362  </span>	 * @return The newly spliced array or the removed element in function of the flag parameter.
<span class="lineno" id="363">   363  </span>	 */</span>
<span class="lineno" id="364">   364  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> pierce(ar:Array, index:Number, flag:Boolean ) 
<span class="lineno" id="365">   365  </span>	{
<span class="lineno" id="366">   366  </span> 		<span class="key">var</span> item = ar[index] ;
<span class="lineno" id="367">   367  </span> 		ar.splice(index, <span class="num_const">1</span>) ;
<span class="lineno" id="368">   368  </span>  		<span class="key">return</span> (flag) ? ar : item ;
<span class="lineno" id="369">   369  </span>	}
<span class="lineno" id="370">   370  </span>
<span class="lineno" id="371">   371  </span>	<span class="comment doc">/**
<span class="lineno" id="372">   372  </span>	 * Tests whether some element in the array passes the test implemented by the provided function.
<span class="lineno" id="373">   373  </span>	 * &lt;p&gt;{@code some} executes the {@code callback} function once for each element present in the array until it finds one where callback returns a {@code true} value. 
<span class="lineno" id="374">   374  </span>	 * If such an element is found, some immediately returns {@code true}. Otherwise, some returns false. {@code callback} is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values.&lt;/p&gt;
<span class="lineno" id="375">   375  </span>	 * &lt;p&gt;{@code callback} is invoked with three arguments: the value of the element, the index of the element, and the Array object being traversed.&lt;/p&gt;
<span class="lineno" id="376">   376  </span>	 * &lt;p&gt;If a {@code thisObject} parameter is provided to some, it will be used as the this for each invocation of the callback. If it is not provided, or is null, the global object associated with callback is used instead.&lt;/p&gt;
<span class="lineno" id="377">   377  </span>	 * &lt;p&gt;{@code some} does not mutate the array on which it is called.&lt;/p&gt;
<span class="lineno" id="378">   378  </span>	 * &lt;p&gt;The range of elements processed by some is set before the first invocation of callback. Elements that are appended to the array after the call to some begins will not be visited by callback. If an existing, unvisited element of the array is changed by callback, its value passed to the visiting callback will be the value at the time that some visits that element's index; elements that are deleted are not visited.&lt;/p&gt;
<span class="lineno" id="379">   379  </span>	 * &lt;p&gt;&lt;b&gt;Example :&lt;/b&gt;&lt;/p&gt;
<span class="lineno" id="380">   380  </span>	 * The following example tests whether some element in the array is bigger than 10.
<span class="lineno" id="381">   381  </span>	 * {@code
<span class="lineno" id="382">   382  </span>	 * import vegas.util.ArrayUtil ;
<span class="lineno" id="383">   383  </span>	 * function isBigEnough(element, index, array) 
<span class="lineno" id="384">   384  </span>	 * {
<span class="lineno" id="385">   385  </span>	 *     return (element &gt;= 10);
<span class="lineno" id="386">   386  </span>	 * }
<span class="lineno" id="387">   387  </span>	 * var passed:Boolean ;
<span class="lineno" id="388">   388  </span>	 * passed = ArrayUtil.some([2, 5, 8, 1, 4], isBigEnough)  ; // passed is false
<span class="lineno" id="389">   389  </span>	 * passed = ArrayUtil.some([12, 5, 8, 1, 4], isBigEnough) ; // passed is true
<span class="lineno" id="390">   390  </span>	 * }
<span class="lineno" id="391">   391  </span>	 * @param ar The array to some.
<span class="lineno" id="392">   392  </span>	 * @param callback Function to test for each element.
<span class="lineno" id="393">   393  </span>	 * @param thisObject Object to use as this when executing callback.
<span class="lineno" id="394">   394  </span>	 */</span>
<span class="lineno" id="395">   395  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> some( ar:Array, callback:Function, thisObject):Boolean 
<span class="lineno" id="396">   396  </span>	{
<span class="lineno" id="397">   397  </span>        
<span class="lineno" id="398">   398  </span>        <span class="key">var</span> len:Number = ar.length ;
<span class="lineno" id="399">   399  </span>        <span class="key">var</span> i:Number = <span class="num_const">0</span> ;
<span class="lineno" id="400">   400  </span>        
<span class="lineno" id="401">   401  </span>        <span class="key">if</span>( thisObject == <span class="key">null</span> ) thisObject = _global ;
<span class="lineno" id="402">   402  </span>       
<span class="lineno" id="403">   403  </span>        <span class="key">for</span>( i=<span class="num_const">0</span>; i&lt;len; i++ ) 
<span class="lineno" id="404">   404  </span>        {
<span class="lineno" id="405">   405  </span>            <span class="key">if</span>( callback.call( thisObject, ar[i], i, ar ) ) 
<span class="lineno" id="406">   406  </span>            {
<span class="lineno" id="407">   407  </span>            	<span class="key">return</span> <span class="key">true</span> ;
<span class="lineno" id="408">   408  </span>            }
<span class="lineno" id="409">   409  </span>		}
<span class="lineno" id="410">   410  </span>        
<span class="lineno" id="411">   411  </span>        <span class="key">return</span> <span class="key">false</span>;
<span class="lineno" id="412">   412  </span>   
<span class="lineno" id="413">   413  </span>    }
<span class="lineno" id="414">   414  </span>
<span class="lineno" id="415">   415  </span>	<span class="comment doc">/**
<span class="lineno" id="416">   416  </span>	 * Shuffles an array.
<span class="lineno" id="417">   417  </span>	 * &lt;p&gt;{@code
<span class="lineno" id="418">   418  </span>	 * import vegas.util.ArrayUtil ;
<span class="lineno" id="419">   419  </span>	 * var ar = new Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
<span class="lineno" id="420">   420  </span>	 * trace("+ " + ar);
<span class="lineno" id="421">   421  </span>	 * ArrayUtil.shuffle(ar);
<span class="lineno" id="422">   422  </span>	 * trace("+ " + ar) ;
<span class="lineno" id="423">   423  </span>	 * }
<span class="lineno" id="424">   424  </span>	 * &lt;/p&gt;
<span class="lineno" id="425">   425  </span>	 * @return the shuffled array.
<span class="lineno" id="426">   426  </span>	 * @see ArrayUtil {@code pierce()} method.
<span class="lineno" id="427">   427  </span>	 */</span>
<span class="lineno" id="428">   428  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> shuffle( ar:Array) 
<span class="lineno" id="429">   429  </span>	{
<span class="lineno" id="430">   430  </span> 		<span class="key">var</span> tmp:Array = [] ;
<span class="lineno" id="431">   431  </span> 		<span class="key">var</span> len = ar.length;
<span class="lineno" id="432">   432  </span> 		<span class="key">var</span> index = len - <span class="num_const">1</span> ;
<span class="lineno" id="433">   433  </span> 		<span class="key">for</span> (<span class="key">var</span> i:Number = <span class="num_const">0</span>; i &lt; len; i++) 
<span class="lineno" id="434">   434  </span> 		{
<span class="lineno" id="435">   435  </span>  			tmp.push( ArrayUtil.pierce( ar, Math.round(Math.random() * index), <span class="key">false</span>) );
<span class="lineno" id="436">   436  </span>  			index-- ;
<span class="lineno" id="437">   437  </span> 		}
<span class="lineno" id="438">   438  </span> 		<span class="key">while</span>(--len &gt; -<span class="num_const">1</span>) 
<span class="lineno" id="439">   439  </span> 		{
<span class="lineno" id="440">   440  </span>  			ar[len] = tmp[len] ;
<span class="lineno" id="441">   441  </span> 		}
<span class="lineno" id="442">   442  </span> 		<span class="key">return</span> ar ;
<span class="lineno" id="443">   443  </span>	}
<span class="lineno" id="444">   444  </span>
<span class="lineno" id="445">   445  </span>	<span class="comment doc">/**
<span class="lineno" id="446">   446  </span>	 * Returns a string representing the specified array and its elements.
<span class="lineno" id="447">   447  </span>	 * @return a string representing the specified array and its elements.
<span class="lineno" id="448">   448  </span>	 */</span>
<span class="lineno" id="449">   449  </span>	<span class="key">public</span> <span class="key">static</span> <span class="key">function</span> toString(ar:Array, strJoin:String ):String 
<span class="lineno" id="450">   450  </span>	{
<span class="lineno" id="451">   451  </span>		<span class="key">return</span> ar.join( strJoin || <span class="str_const">","</span> ) ;
<span class="lineno" id="452">   452  </span>	}
<span class="lineno" id="453">   453  </span>	
<span class="lineno" id="454">   454  </span>}</pre><ul class="main_nav" id="main_nav"><li><a href="../../overview-summary.html" title="Overview of API" class="button">Overview</a></li><li><a href="package-summary.html" title="Overview of package vegas.util" class="button">Package</a></li><li><a href="ArrayUtil.html" title="Detail of vegas.util.ArrayUtil API" class="button">Class</a></li><li><span class="button nav_current">Source</span></li><li><a href="../../index-files/index.html" title="Alpabetical index of types and members" class="button">Index</a></li></ul><div class="footer"><a href="http://www.badgers-in-foil.co.uk/projects/as2api/" title="ActionScript 2 API Documentation Generator">as2api</a></div></body></html>